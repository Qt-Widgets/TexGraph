#include "OBJLoader.h"

#include "../FString.h"
#include "../GeneralUtility.h"
#include "../Geometry/MeshData.h"

//#include "../Geometry/tiny_obj_loader.h"
#define TINYOBJLOADER_IMPLEMENTATION
#include "../Geometry/tiny_obj_loader.h"

#include "../Logging.h"
#include "../Resource.h"

#include <sstream>

namespace SprueEngine
{

const std::string OBJLoader::resourceURI_("Mesh");
const StringHash  OBJLoader::typeHash_("Mesh");

std::string OBJLoader::GetResourceURIRoot() const
{
    return resourceURI_;
}

StringHash OBJLoader::GetResourceTypeID() const
{
    return typeHash_;
}

bool OBJLoader::CanLoad(const char* str) const
{
    return EndsWith(ToLower(str), ".obj");
}

std::shared_ptr<Resource> OBJLoader::LoadResource(const char* fileName) const
{
    std::vector<tinyobj::shape_t> shapes;
    std::vector<tinyobj::material_t> materials;
    std::string errMsg;
    if (tinyobj::LoadObj(shapes, materials, errMsg, fileName))
    {
        std::vector<MeshData*> ret;

        for (auto shape : shapes)
        {
            if (shape.mesh.indices.empty())
                continue;

            MeshData* mesh = new MeshData();
            mesh->SetName(shape.name);

            mesh->positionBuffer_.resize(shape.mesh.positions.size() / 3);
            mesh->normalBuffer_.resize(shape.mesh.normals.size() / 3);
            mesh->uvBuffer_.resize(shape.mesh.texcoords.size() / 2);
            mesh->indexBuffer_.resize(shape.mesh.indices.size());
            

            memcpy(mesh->positionBuffer_.data(), shape.mesh.positions.data(), sizeof(Vec3) * mesh->positionBuffer_.size());
            if (mesh->normalBuffer_.size() > 0)
                memcpy(mesh->normalBuffer_.data(), shape.mesh.normals.data(), sizeof(Vec3) * mesh->normalBuffer_.size());
            if (mesh->uvBuffer_.size() > 0)
                memcpy(mesh->uvBuffer_.data(), shape.mesh.texcoords.data(), sizeof(Vec2) * mesh->uvBuffer_.size());
            memcpy(mesh->indexBuffer_.data(), shape.mesh.indices.data(), sizeof(unsigned) * mesh->indexBuffer_.size());

            if (mesh->normalBuffer_.empty())
                mesh->CalculateNormals();

            //auto uvMaxIt = std::max_element(mesh->uvBuffer_.begin(), mesh->uvBuffer_.end(), [](const Vec2& lhs, const Vec2& rhs) { return lhs.y < rhs.y; });
            //const float uvMax = uvMaxIt != mesh->uvBuffer_.end() ? uvMaxIt->y : 0.0f;

            // Modelers usually output with 0,0 at bottom left, we use 0,0 at top left
            // OBJ files have upside down coordinates
            for (unsigned i = 0; i < mesh->uvBuffer_.size(); ++i)
                mesh->uvBuffer_[i].y = 0.5f - (mesh->uvBuffer_[i].y - 0.5f); // flip around 0.5,0.5
                //mesh->uvBuffer_[i].y *= -1.0f;

            mesh->CalculateTangents();
            mesh->CalculateBounds();

            ret.push_back(mesh);
        }

        std::shared_ptr<MeshResource> meshRes = std::make_shared<MeshResource>();
        meshRes->GetMeshes() = ret;

        return meshRes;
    }
    else
        SPRUE_LOG_ERROR(FString("Unable to load OBJ file: %1, %2", fileName, errMsg).str());

    return 0x0;
}

void OBJLoader::SaveModel(const std::vector<MeshData*>& meshData, const char* fileName)
{
    uint64_t currentPosIndex = 1;
    uint64_t currentUVIndex = 1;
    uint64_t currentNormIndex = 1;
    
    std::ofstream output;
    output.open(fileName, std::ios::out | std::ios::trunc);
    if (!output.is_open())
        return;

    output << "# Generated by SprueKit" << std::endl;

    for (unsigned meshIdx = 0; meshIdx < meshData.size(); ++meshIdx)
    {
        const auto mesh = meshData[meshIdx];
        if (mesh->positionBuffer_.size() > 0)
        {
            const bool hasUV = !mesh->uvBuffer_.empty();
            const bool hasNorm = !mesh->normalBuffer_.empty();

            output << "o ";
            if (mesh->GetName().empty())
            {
                output << "unnamed_";
                output << meshIdx;
            }
            else
                 output << mesh->GetName();

            output << std::endl;

            for (unsigned i = 0; i < mesh->positionBuffer_.size(); ++i)
                output << "v " << mesh->positionBuffer_[i].x << " " <<  mesh->positionBuffer_[i].y << " " << mesh->positionBuffer_[i].z << std::endl;
            for (unsigned i = 0; i < mesh->uvBuffer_.size(); ++i)
                output << "vt " << mesh->uvBuffer_[i].x << " " << mesh->uvBuffer_[i].y << std::endl;
            for (unsigned i = 0; i < mesh->normalBuffer_.size(); ++i)
                output << "vn " << mesh->normalBuffer_[i].x << " " << mesh->normalBuffer_[i].y << " " << mesh->normalBuffer_[i].z << std::endl;

            for (unsigned i = 0; i < mesh->indexBuffer_.size(); i += 3)
            {
                const unsigned v0 = mesh->indexBuffer_[i];
                const unsigned v1 = mesh->indexBuffer_[i+1];
                const unsigned v2 = mesh->indexBuffer_[i+2];

                if (hasUV && hasNorm)
                {
                    output << "f " 
                        << v0 + currentPosIndex << "/" << v0 + currentUVIndex << "/" << v0 + currentNormIndex << " "
                        << v1 + currentPosIndex << "/" << v1 + currentUVIndex << "/" << v1 + currentNormIndex << " "
                        << v2 + currentPosIndex << "/" << v2 + currentUVIndex << "/" << v2 + currentNormIndex << std::endl;
                }
                else if (hasUV)
                {
                    output << "f " << v0 + currentPosIndex << "/" << v0 + currentUVIndex << " "
                        << v1 + currentPosIndex << "/" << v1 + currentUVIndex << " "
                        << v2 + currentPosIndex << "/" << v2 + currentUVIndex << std::endl;
                }
                else if (hasNorm)
                {
                    output << "f " << v0 + currentPosIndex << "//" << v0 + currentUVIndex << " "
                        << v1 + currentPosIndex << "//" << v1 + currentUVIndex << " "
                        << v2 + currentPosIndex << "//" << v2 + currentUVIndex << std::endl;
                }
                else
                {
                    output << "f " << v0 + currentPosIndex << " "
                        << v1 + currentPosIndex << " "
                        << v2 + currentPosIndex << std::endl;
                }
            }

            output << std::endl;

            currentPosIndex += mesh->positionBuffer_.size();
            currentUVIndex += mesh->uvBuffer_.size();
            currentNormIndex += mesh->normalBuffer_.size();
        }
    }

    output.close();
}

}