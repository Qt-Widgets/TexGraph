// FastNoise.cpp
//
// MIT License
//
// Copyright(c) 2016 Jordan Peck
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// The developer's email is jorzixdan.me2@gzixmail.com (for great email, take
// off every 'zix'.)
//

#include "FastNoise.h"
#include <math.h>

namespace SprueEngine
{

#define LUT_MASK 127

static const float VAL_LUT[] =
{
	-0.92125984251968f, 0.826771653543307f, -0.1496062992126f, -0.38582677165354f, 0.039370078740159f, -0.74803149606299f, 0.937007874015748f, 0.858267716535433f, 0.448818897637796f, 0.118110236220474f, -0.73228346456693f, -0.16535433070866f, -0.60629921259842f, 0.637795275590552f, -0.0393700787401601f, 0.354330708661418f, 0.291338582677167f, 0.181102362204726f, -0.7007874015748f, -0.10236220472441f, -0.84251968503937f,
	-0.0551181102362199f, -0.48031496062992f, 0.259842519685041f, 0.165354330708663f, 0.84251968503937f, 0.779527559055119f, -0.81102362204724f, -0.19685039370079f, 0.196850393700789f, 0.669291338582678f, 0.070866141732285f, 0.921259842519685f, -0.18110236220472f, 0.228346456692915f, 0.00787401574803304f, 0.700787401574804f, -0.85826771653543f, 0.023622047244096f, 0.133858267716537f, 0.322834645669293f, -0.93700787401574f,
	-0.29133858267716f, 0.370078740157481f, -0.66929133858267f, -0.96850393700787f, 0.401574803149607f, -0.33858267716535f, -0.4015748031496f, 0.73228346456693f, -0.55905511811023f, -0.43307086614173f, 0.763779527559056f, -0.46456692913386f, 0.543307086614174f, -0.76377952755905f, 0.685039370078741f, 0.748031496062993f, 1.0f, 0.795275590551181f, -0.5748031496063f, -0.54330708661417f, 0.653543307086615f, 0.952755905511811f,
	0.338582677165356f, -0.21259842519685f, 0.433070866141733f, 0.511811023622048f, 0.622047244094489f, -0.90551181102362f, -0.79527559055118f, 0.590551181102363f, -0.11811023622047f, 0.212598425196852f, -0.41732283464567f, -0.95275590551181f, -0.63779527559055f, 0.244094488188978f, 0.30708661417323f, 0.968503937007874f, 0.606299212598426f, -0.77952755905511f, -0.88976377952756f, -0.24409448818897f, -0.32283464566929f,
	-0.71653543307086f, 0.716535433070867f, 0.5748031496063f, 0.086614173228348f, -0.98425196850393f, -0.13385826771653f, -0.51181102362204f, -0.8267716535433f, 0.874015748031496f, -0.35433070866141f, 0.905511811023622f, 0.811023622047244f, -0.68503937007874f, 0.480314960629922f, -0.37007874015748f, -0.2755905511811f, 0.102362204724411f, 0.527559055118111f, -0.44881889763779f, 0.889763779527559f, 0.41732283464567f,
	0.984251968503937f, 0.385826771653544f, -0.87401574803149f, -0.30708661417323f, -0.62204724409449f, -0.52755905511811f, 0.1496062992126f, -0.0866141732283401f, 0.496062992125985f, -0.25984251968504f, -1.0f, -0.59055118110236f, 0.464566929133859f, -0.00787401574802993f, -0.22834645669291f, -0.65354330708661f, -0.49606299212598f, 0.055118110236222f, 0.559055118110237f, -0.07086614173228f, -0.02362204724409f, 0.275590551181104f
};

static const float GRAD4D_LUT[][4] =
{
	{ 0.0179285344989033f, 0.0677944464204167f, 0.900387877028038f, 0.429399757319696f }, { 0.151459767976519f, 0.41940331430838f, 0.025942750707592f, -0.894699822464143f }, { 0.979529859361997f, 0.130367466451577f, -0.00937681736873056f, -0.153093610595927f }, { 0.0188035720634411f, 0.957989228554963f, -0.269676405489343f, 0.0958003130092474f }, { -0.0012369876892f, -7.87528807201163E-05f, 0.000149907955282427f, -0.999999220593219f }, { -0.0515998001407824f, -0.944373511413844f, 0.324801510463498f, 0.000332213707707317f }, { 0.0625583127110917f, 0.368853467530968f, 0.927379950072298f, 7.21458539681357E-05f }, { -0.0332301888025581f, 0.00487951365898265f, -0.999435388671684f, 0.000921286751161818f },
	{ 0.254162385940239f, -0.00247502010266267f, 0.000438725101563024f, 0.967158292819196f }, { -0.759302539566954f, -0.650633735433763f, -0.0116359665914368f, 2.04111122123566E-06f }, { -4.48759951174869E-08f, 0.358287711147997f, -0.933611212169481f, 0.000143358851029576f }, { -0.834876133401752f, -0.194359576306317f, -0.0344898444893627f, -0.513825503066234f }, { 0.992418907081551f, 4.57210674843702E-06f, -1.83490711870738E-06f, 0.122901232063752f }, { -0.42938540950326f, 0.513195588850885f, -0.743126271370401f, -0.00466931352956133f }, { 0.570845731350832f, 1.65553932296542E-05f, 0.0011349034293071f, 0.821056552692115f }, { 2.31617888342864E-05f, 0.994847097173254f, -0.0961577881592109f, -0.0321392670390731f },
	{ 0.0285107567449309f, -0.0502599346018885f, -0.998329141978559f, 2.92045363529652E-10f }, { 0.693061667730217f, 0.081528197183571f, -0.606560258101509f, 0.380924311483053f }, { -0.471772182045896f, -0.105811692623359f, 0.875348441445287f, 3.33769803143138E-06f }, { 0.362766768879719f, 0.923039277394957f, -0.128057658031582f, -1.49328116922925E-06f }, { 0.062046368142898f, -0.815075843570167f, 0.576022235980786f, -3.29295020122024E-05f }, { -0.921787687217261f, 0.28869133264405f, 0.0732935586853114f, -0.248179024911652f }, { -5.47319853185622E-06f, 0.973767617716296f, 0.225257152279963f, -0.0321844994352065f }, { 0.232218374389583f, -0.08472237319722f, -0.137241903519584f, 0.95919831421558f },
	{ -0.0167570140621457f, 0.358790865544362f, 0.933267510677344f, 0.000266074731502954f }, { 0.0107254303176227f, -0.737658920753904f, 1.52650004111161E-06f, -0.675088351087735f }, { -3.71325911057143E-06f, -0.448149367809768f, 0.893952928186452f, 0.00321034340618395f }, { -0.0163066755437812f, -0.0444639669567192f, -0.998877894427004f, -5.06860474025719E-07f }, { 0.085934337625112f, -8.88863502634554E-05f, 0.996300798791311f, 6.62916977146475E-06f }, { 0.018848679157187f, -0.168704308520019f, 0.583111361978302f, 0.794458761115151f }, { -0.14092365680382f, -0.0262056616259223f, 0.00425806403039333f, -0.989664415416913f }, { 0.000019585584043321f, 0.0708482693257697f, 0.094787939700978f, 0.992973196434421f },
	{ -3.61195284939247E-07f, 0.573786610288797f, -0.00565371182001549f, -0.818985324285984f }, { 0.555482972457819f, -0.831524637330389f, 0.00233255322693632f, 6.33832316941843E-05f }, { 0.800371000342067f, 0.168341324992158f, 8.13736079413595E-08f, -0.575384619286367f }, { -0.151943784159287f, -3.17003100215728E-06f, -0.973809705113584f, 0.169138241305451f }, { -3.28617107642979E-10f, -2.51664008452886E-05f, -0.999999889743206f, 0.000468913880721174f }, { 0.144708070244843f, -0.392246876333683f, -0.14750809340107f, 0.896350001279446f }, { -0.499891693213082f, 0.000469340668710032f, -0.0432191264563471f, 0.865008775611117f }, { -0.74530243187983f, -0.0130445109718722f, 0.0435702095816092f, 0.665173483088833f },
	{ -0.796157099668477f, 0.000124118278989671f, -0.00217167212139707f, -0.605086060889134f }, { 0.947484791701284f, 0.0724121319093247f, 3.87510235633725E-05f, -0.311494865359736f }, { 0.999997268027888f, -0.00183696890994059f, 0.00144542293102575f, 0.000015314536027456f }, { 0.246103794412299f, 0.967730041656212f, 0.05414322404818f, -1.18997457774053E-05f }, { 4.28260722805506E-05f, -0.999999938144512f, -0.00024875421527231f, -0.000244945380014729f }, { 0.345932094721763f, -0.00182445228148537f, -2.01050360940934E-07f, 0.938257777593794f }, { 0.232629530802398f, -0.0123421039259699f, -0.000333195046776704f, -0.972487050222468f }, { -0.0413343034477463f, -0.845558019383741f, -0.532041468453896f, 0.0159683142427982f },
	{ 4.876953380543E-11f, -0.509395810571092f, -0.760866765012863f, -0.401992131852703f }, { 0.01457871782159f, 0.00352273519283274f, 2.46006626805202E-08f, 0.999887519335769f }, { -0.2197566484112f, -0.269663250455668f, 0.936190779005179f, -0.0503544649304871f }, { -0.0865455281910523f, 0.0990053597028644f, -2.66646365439371E-05f, 0.991316200608683f }, { -0.989058271919771f, -0.130356511156493f, -0.0535910970499983f, -0.0435764737348075f }, { 0.900013078389142f, -0.00043287841542218f, -2.83509325586139E-08f, -0.435862674869937f }, { -0.771015568252326f, -4.76900694356318E-05f, -0.0219363831312084f, 0.636438360199416f }, { -0.078643371273305f, 0.996901923608738f, -6.16073674743889E-06f, 0.00133222446022512f },
	{ 5.20470758906282E-05f, 0.997256243992129f, 0.0740268623204818f, 6.90275154123082E-05f }, { -0.115896931950432f, -0.300911764975683f, 0.431409257232567f, -0.842559234497932f }, { -1.05936323695781E-10f, -0.0143409648185513f, -0.999897162703251f, 2.73141203266667E-05f }, { 7.36602805763734E-06f, 0.0490840386576873f, -0.187410880606716f, 0.981054493351418f }, { -0.149217229776082f, 0.096219097342591f, 0.984104045608208f, -0.00391549001869267f }, { 0.0301779956805262f, -2.03984355987402E-05f, -0.999544181133284f, -0.00084742150235282f }, { 0.101389753295397f, 0.00105726742868962f, 0.994846219323528f, 3.15683454673068E-06f }, { -0.0132313717977117f, 0.159525525289995f, 0.593084588401323f, -0.789067302948319f },
	{ -0.999950751279126f, -2.28154321862005E-06f, -3.35621991002035E-07f, 0.00992446527495385f }, { -0.446140024906362f, -0.89496104730281f, -0.000949959838625011f, -0.00170281047488805f }, { -0.25830870420065f, -5.99271603499866E-11f, -0.962897969373127f, -0.0781288289384209f }, { -0.0141578535996954f, -0.590108238154547f, 0.772903767582682f, -0.232790868592566f }, { -0.0408946388040428f, -0.487869969082088f, -2.38283754617856E-06f, -0.871957866974805f }, { 0.993390567418713f, 0.114783068234581f, 0.000166763855068009f, -7.22479963187292E-13f }, { -0.150270957910884f, 0.98861713652712f, 0.00724343322227505f, 0.00152618760893165f }, { -0.0292187624948691f, 0.984282454781429f, -2.54315254401317E-06f, -0.174167485832589f },
	{ 0.605498435491149f, 0.0295366828327539f, -0.261172160527168f, 0.75119127494306f }, { -0.00453574210785455f, 0.0164722766698647f, -0.00759597400463439f, -0.99982518088102f }, { -0.161906996023123f, -0.968938255461586f, 0.00479280806368259f, 0.186873782892868f }, { 0.0718297493332595f, -0.15117444225596f, -0.95710224645937f, 0.236520749495151f }, { 1.55364291766971E-08f, 0.751515349174519f, -0.513260578427611f, -0.414473471512055f }, { -0.0832231266679871f, -0.016036973751982f, -0.150197717417989f, 0.985016432524305f }, { -0.0499060179903397f, 0.113056945464528f, 0.760889993198006f, 0.637003873380466f }, { -0.912217939109183f, -0.000236556733323175f, 0.409698193304452f, -0.00240125204303045f },
	{ -0.0201341577237124f, 0.822200561754789f, -0.0353638581788924f, -0.567741357906546f }, { 0.981833737365851f, -0.189743278357464f, 1.93574210616191E-05f, 1.06610391592544E-05f }, { -3.1713467661518E-06f, -0.999998467923194f, -3.10580174237511E-07f, -0.00175046882587876f }, { 0.999785072721677f, 0.00661572799000603f, -0.000560396757787285f, -0.0196399201003463f }, { 0.947369318875243f, 0.10413625625988f, 0.014573335884325f, 0.302381599419074f }, { 0.000539050555161111f, 0.363169172188698f, -0.0860769990608411f, 0.927738439447755f }, { 0.0218600193860152f, 0.0136508664574171f, -0.957380820600311f, 0.287676481040908f }, { 0.0452753695684423f, -3.62412965753121E-05f, 0.412640274130687f, -0.909768181331025f },
	{ -6.91937018588465E-08f, 0.000924049891480408f, -0.998173949198153f, 0.0603979575313267f }, { 0.0524759516860929f, 0.0348710315338021f, -0.997989141515491f, -0.00692524884613554f }, { -0.000620065691267785f, -0.297909553995998f, -0.954593871695887f, -0.000230818326052339f }, { -6.96674135940915E-05f, -0.867754661790055f, 0.496992798829057f, 3.74443548432658E-07f }, { -0.0482481401493802f, 0.00489619615662811f, -0.995799001490995f, 0.0776691242699415f }, { -0.151673443794422f, -0.974774864011805f, -0.000484445743305936f, -0.163734224432859f }, { -0.049803009786826f, 0.0811460037036778f, -0.0626532599996605f, -0.993483545566061f }, { -0.0609700565049769f, 0.169557563496092f, 0.340322391745786f, 0.922883283274476f },
	{ -0.907810279284789f, -9.09566645872125E-05f, -6.82944907490262E-07f, -0.419381077960479f }, { -0.0974613227620325f, 0.995239313157134f, 5.15261588579082E-11f, -1.05825987794001E-05f }, { -0.0186861500087666f, 0.00438118107716855f, 0.992023504204221f, -0.124583306091132f }, { -0.930838673636572f, -0.0110467691436416f, -0.00188202425659556f, 0.365258525620815f }, { -0.0567494686643164f, -2.42763994429726E-09f, 0.975143948519116f, -0.214181645975711f }, { 0.0304023604642125f, -0.632969000014441f, 0.773579295645911f, 0.00100739609776072f }, { 0.000108520483850958f, 0.0583209179359306f, -0.00851497409325953f, -0.998261565908758f }, { -0.02385578591046f, -0.129946314819517f, 0.0562422070557562f, -0.989637141021354f },
	{ -0.00504915323521923f, -0.0089236566539032f, -0.000176312774898594f, 0.999947420276354f }, { 9.54792136888334E-10f, 0.95741607332861f, -0.000200174641238177f, 0.288711659726688f }, { 0.994168345296552f, 0.107836831627415f, 0.000720385221359334f, 1.00702166459814E-07f }, { -0.442903722280488f, 0.0490533033131452f, -0.286717020869704f, 0.848070407553381f }, { -0.579123085419419f, 0.000412386634095739f, 0.000548850089152674f, -0.81523983013291f }, { -0.99748331906203f, -0.00315622682426633f, -0.0314712268933373f, -0.0634557192304806f }, { -0.999910167988914f, 0.00277348539595252f, -0.0131131747511067f, -9.15373542722021E-05f }, { 0.989849756616008f, -0.102100397263962f, -0.0925741321036343f, -0.0346842654676267f },
	{ -0.0502665295186573f, -0.0019502335925594f, 0.995313667448867f, -0.0825843568030342f }, { -0.775008311628356f, 0.00458914577239442f, 0.631802950284916f, 0.012887538916389f }, { -0.917122758231958f, 3.16141922995542E-09f, 0.00144102092010558f, -0.398602270178826f }, { 0.298077607094876f, 0.0476089996782551f, 0.875582290533107f, 0.377145563149066f }, { 0.263407146338272f, -0.473950966620194f, 0.840230003541957f, -0.000835251815231092f }, { -0.55558964464076f, 0.00104388539977359f, -0.000884120434714965f, -0.831455516189702f }, { 0.857295578944858f, -0.0176694994052872f, -0.51054240707814f, -0.0638633673339165f }, { 0.0864515147611175f, -0.35114135064002f, 0.922138824225689f, 0.137425893927874f },
	{ 0.968780126999011f, 0.203315714499582f, -0.141786558529076f, -0.00493534089860906f }, { -0.0103473943005527f, -0.0446849068409796f, -0.625161129502578f, -0.779146810742919f }, { -0.810284066914716f, -0.582923322911606f, -0.0599165375134594f, 0.00708089275712812f }, { -0.914614581816782f, 0.366353079295109f, 0.00173954895166334f, -0.171063035131932f }, { -0.0017333110902601f, 0.0325427046350465f, -0.999147497892685f, 0.0253425622715693f }, { 0.000847670819166468f, 0.0188099412466175f, 0.999636928304481f, 0.019273793982079f }, { 0.100715508011326f, 0.994914522159042f, -0.000565737742910064f, 0.00107702547448881f }, { -0.414687299306508f, -0.734201866849646f, -0.536852323837964f, -0.0277784970462061f },
};

static const float GRAD3D_LUT[][3] =
{
	{ 0.969192790963703f, -0.204588387787502f, -0.137145636191962f }, { 0.0105050866706296f, 0.869235070511719f, -0.494287401565657f }, { -0.00713466534361336f, -0.0561560433951495f, -0.998396512083569f }, { -0.99998707996014f, 0.00085789886042815f, 0.00501038145637507f }, { -0.729044421579981f, -0.0724223391156089f, 0.680624151907743f }, { -0.769477416524206f, 0.638612501748049f, 0.00886442724220208f }, { -0.148489274637499f, -0.733777362959066f, 0.662964340614538f }, { 0.00192647521945516f, -0.688227670545063f, 0.725492220626345f },
	{ 0.307853961011481f, -0.888296843306306f, 0.340814695782903f }, { -0.136873983993337f, 0.99058218544213f, 0.0035279442294635f }, { 0.981422965662359f, 0.0873011939299262f, -0.170843390299155f }, { 0.977985182924792f, 0.0274298762917452f, 0.206863684261352f }, { -4.10904184278805E-08f, -0.984715746607902f, -0.174169165992265f }, { -0.00576047279073815f, -0.00207046110763061f, 0.999981264896512f }, { 0.385796494451913f, -0.382885124111844f, 0.839380751865608f }, { 0.196898025871543f, -0.533803208609833f, 0.822365674068256f },
	{ -0.953574229510659f, -0.197141111727736f, -0.227665480211439f }, { 0.958192898763756f, -0.00565943080050262f, 0.286067019423289f }, { -0.000021414243574488f, 0.308183457620683f, 0.951326944846192f }, { -0.00156590253858546f, -0.936777289401244f, -0.349922645753741f }, { 0.010162930999189f, 0.907036729301754f, 0.420928837846829f }, { -0.0468274165634939f, 0.74026530347444f, -0.670682095727837f }, { -0.958782958606567f, 0.0676203469753538f, -0.275975953591197f }, { 0.000771226398681087f, -0.963152702156633f, 0.268954043543163f },
	{ -0.939601847652347f, 0.341933173840782f, -0.0151681414637957f }, { 0.0836248033533964f, 0.431468628956066f, 0.898243683245743f }, { -0.97637082132863f, 0.118948680332271f, 0.180419596234078f }, { 0.103518422502263f, 0.000465187240855595f, -0.994627427634827f }, { -0.141353740004181f, 0.0778654829014707f, -0.98689213532146f }, { 0.0700630230682292f, 0.912644877864809f, -0.402703985212052f }, { 0.991874945122624f, -0.0502217417385342f, 0.116884001876814f }, { -0.707119760481927f, 0.700142261026601f, -0.0989063125414175f },
	{ 0.0976913606831578f, 0.99518571412564f, -0.00786081726752686f }, { 0.865756754070504f, 0.268594575188625f, 0.422282129577546f }, { 0.0124864728918991f, -0.922679395826772f, -0.385365826859963f }, { -0.0174011080646746f, -0.984212730893662f, 0.176132057800279f }, { 0.983085383617433f, 0.183144250425653f, 0.00114544916535278f }, { 0.84177325324929f, -0.000849099388075524f, 0.539830593005191f }, { -0.773202768542597f, 0.634158480426922f, -0.000707404184135718f }, { -0.399463762408861f, 0.520122522942901f, -0.754918050949683f },
	{ -0.0543404007696243f, 0.853240000077495f, -0.51867969221086f }, { 0.0787561128671418f, -0.0445112338899157f, -0.995899706167069f }, { -0.149110911377271f, -0.855893524471146f, -0.495189065788614f }, { 0.128579845943545f, 0.95447163354276f, 0.26916746456314f }, { -6.48712081276198E-06f, -0.417292224145094f, 0.908772358528778f }, { -0.18395289837094f, 0.967255425062472f, 0.174866445804071f }, { -0.0956465003848313f, -0.995413983868259f, -0.00165761384418054f }, { -0.493402767926647f, 0.252656257103973f, 0.83229713705415f },
	{ 0.941743815026262f, -0.00313821941824732f, 0.336316426061328f }, { -0.406002839825049f, -0.660621950516609f, -0.631458892208849f }, { -0.0151930656231186f, 0.000118750826499392f, 0.999884571665756f }, { 0.681786958463344f, -0.719431781259153f, 0.132606392695014f }, { 0.973323591185432f, -0.228922756390528f, 0.0153479134887209f }, { -0.810634856852843f, -0.585551171144037f, 0.000977152504195713f }, { -0.181398855060402f, -0.831693356111209f, 0.524767202465292f }, { -0.733900500867695f, 0.679256981569713f, 8.84021970721802E-05f },
	{ 0.271727663466327f, -0.889119678670303f, -0.368280156821335f }, { 0.298233653375395f, -0.0312311598898426f, -0.953981814630813f }, { -0.752318728102205f, -0.00392703305301813f, 0.658787605953604f }, { 0.00665991896444102f, -0.893539727653096f, 0.448934739784101f }, { -0.17274029679022f, 0.981849574845414f, 0.0783083791219516f }, { 0.740984319707759f, -1.24163939998686E-09f, 0.671522328703395f }, { -0.91345982474963f, 0.00101800775270491f, 0.40692764986984f }, { 0.166118424599226f, -0.966950978532905f, -0.193417874362556f },
	{ -0.371630916510155f, 0.92837704130171f, -0.00255559732836468f }, { 0.114876798169617f, 0.991537470331245f, 0.0604712011738797f }, { 0.42509283827761f, -0.861877415693766f, -0.276520160498508f }, { 0.0914177278602429f, 0.937282941514681f, 0.336368081985282f }, { -0.138897098096673f, 0.574329772420649f, -0.806754552916541f }, { 4.20730659972853E-05f, -0.973522779481066f, 0.228590017413966f }, { -0.19883302527571f, -0.769560727972852f, -0.606829229702725f }, { 0.0747279815185906f, 0.375429090417211f, 0.92383371168553f },
	{ 0.0360592551928224f, 0.999349653582228f, 1.40580077597545E-07f }, { -0.630789398266975f, 0.775912761477526f, 0.00800759703705387f }, { 0.999468273136104f, 0.0122075383077114f, -0.0302348640281232f }, { 0.0234858830298487f, 0.722121551769761f, -0.691367397096465f }, { 0.044647769484317f, -0.998966611124733f, -0.00850214902496602f }, { -0.155624581702642f, 0.0567240593672596f, -0.98618627584183f }, { -0.564856042306962f, 0.825189463979779f, 2.46592673497201E-06f }, { -0.00280893077197093f, -0.849678682544325f, 0.527293320968186f },
	{ 0.85760478967376f, 0.0912484314080345f, -0.506149926893406f }, { -0.983676972673489f, -0.138789081908023f, -0.11453036355067f }, { -0.995791780173427f, 0.0916344946719056f, 0.00136011957614869f }, { 0.0705163298667096f, 0.9883873876068f, -0.134602448870495f }, { 0.151288867759186f, -0.946777269461834f, -0.28412053871999f }, { -0.479182164834798f, 2.28582795501955E-06f, 0.877715473772117f }, { -0.920617168247744f, -0.0874211800038508f, -0.380554288918466f }, { 0.647008224881357f, -0.0116892424293656f, -0.76239341454875f },
	{ 0.00348600295131339f, 0.00264876419739902f, 0.999990415869897f }, { 0.293662611616922f, 0.774229458412962f, -0.560652313170918f }, { -0.0230822002633608f, -0.133701316157593f, -0.99075282996756f }, { 0.0891587773276397f, -0.70303221860981f, -0.705546888606285f }, { -0.716380181025389f, -0.675240051032385f, 0.175642562369752f }, { -0.110229513550145f, -0.0380431704478986f, 0.993177814655951f }, { 0.901899360101853f, -0.423583957873496f, -0.0845823556073773f }, { -0.188144760211676f, 0.981876973408649f, 0.0227850454193412f },
	{ -0.992971049488398f, -0.00105311622549315f, -0.118352802350111f }, { 0.974825103742426f, -0.22297088847484f, 2.51166485428216E-06f }, { 0.917736330268161f, 0.253456586759036f, -0.305810050087285f }, { 0.754361752313554f, 0.655909079393725f, -0.0268631013715986f }, { -0.00493426945610691f, 0.999852337890823f, -0.0164607229243032f }, { 0.172163344055272f, 0.977404359568319f, -0.122639719750783f }, { 0.20654798485596f, 0.00802290795582379f, 0.978403578744413f }, { -0.0189935909416278f, -0.956252765802595f, -0.291924461801387f },
	{ -0.298030174309119f, -0.101625749247146f, -0.949131298762838f }, { -0.525057139557522f, -0.851050276233871f, 0.00533174661105069f }, { 0.00362214069523366f, 0.401488407244411f, -0.915856942401558f }, { 0.7517944143271f, 0.19472711592481f, 0.629989292694866f }, { 0.501284099317453f, -0.0225214021165674f, 0.864989617404853f }, { -0.985033512468648f, 0.1680612553394f, -0.0382673982316817f }, { 0.00137633273570574f, -0.0442369494900767f, -0.999020118920542f }, { -0.724166817672979f, -0.688818418185576f, 0.033340770082758f },
	{ -0.0128146550963728f, -0.0397993929245446f, 0.99912551410601f }, { 0.802033957950016f, 0.595775400910827f, -0.0423462154693413f }, { -0.902335114745471f, -0.411652900762455f, -0.127801525777801f }, { 7.40750655087705E-05f, -0.890177016591854f, 0.455614830360591f }, { -0.0563694832642116f, 0.998393830705426f, -0.00567804243293261f }, { 0.804825783463094f, 0.0873894235068948f, -0.587042202002675f }, { 0.902405167679558f, 0.0887442050097385f, -0.421650778989461f }, { 0.0138828478418606f, -0.26021714739708f, 0.965450310858268f },
	{ -0.0235002961872274f, -0.1428517727679f, -0.989465061079056f }, { 0.543378228613975f, 0.00830368325812741f, 0.839446930730399f }, { -0.956960500295924f, 0.0113747804839107f, 0.289995198653906f }, { -0.00858337504492301f, -0.949962410388146f, -0.312246288244364f }, { -0.731827611403257f, 0.00140870300297461f, -0.681488343806152f }, { 0.844453636307317f, 0.498643416559842f, -0.195583228444764f }, { -0.997648624781726f, 0.000128342870118087f, -0.0685361583343983f }, { 0.00700544496566235f, -0.020878882722484f, 0.999757468587804f },
};

static const float GRAD2D_LUT[][2] =
{
	{ 0.465254262011416f, -0.885177084927198f }, { 0.999814701091156f, -0.0192500255065206f }, { 0.562013227349949f, 0.827128244157878f }, { 0.540531763173497f, -0.841323607775599f }, { -0.97869393624958f, 0.20532457024989f }, { -0.022259068317433f, 0.999752236245381f }, { -0.763453105361241f, -0.645863264100288f }, { -0.877652307360767f, 0.479297848299283f },
	{ -0.429945697678765f, 0.902854748587789f }, { -0.880336026899474f, 0.474350587374832f }, { -0.999734062007074f, 0.0230609033395389f }, { 0.961877124516138f, -0.273481987217745f }, { 0.485111864938318f, 0.874452101887844f }, { -0.307899752943979f, 0.951418804805243f }, { -0.991765219175154f, 0.128069317303008f }, { 0.937814305853532f, -0.347137332674633f },
	{ -0.398552509901734f, -0.917145515635893f }, { 0.701222178891205f, -0.712942813857514f }, { 0.873193936119955f, 0.487372906431349f }, { -0.514304676201594f, -0.857607544298191f }, { 0.0428414754286589f, 0.999081882521696f }, { -0.88038067821201f, 0.474267710719338f }, { 0.14177264550869f, 0.989899245875795f }, { -0.887664663265946f, -0.46049044027966f },
	{ 0.999983713358517f, -0.00570727760945115f }, { -0.623600504016441f, -0.781743187620104f }, { 0.888019464508127f, -0.459805861918592f }, { 0.600087177175954f, -0.79993460969569f }, { -0.560441030370991f, 0.828194331951567f }, { 0.958552181052623f, -0.284917033887514f }, { 0.6683586377581f, 0.743839183785136f }, { 0.709718808827001f, 0.704485068966819f },
	{ 0.695776987881928f, 0.718257880662615f }, { 0.154316110318401f, -0.988021527142096f }, { -0.725364342269412f, -0.688365143629501f }, { -0.999918869545931f, 0.0127379090116007f }, { 0.805508244111792f, 0.592584566680519f }, { -0.996506623245929f, 0.0835137702836865f }, { -0.73969279786535f, -0.67294469667732f }, { 0.695504007775371f, -0.718522216196824f },
	{ -0.999983227160896f, 0.00579183881678425f }, { -0.714924640549655f, 0.699201514825981f }, { -0.835103934916504f, -0.550092190352645f }, { 0.84959050330652f, 0.527442865807639f }, { -0.171610706906682f, 0.985164841676249f }, { 0.3561994988697f, 0.934409929851441f }, { -0.409182557485348f, -0.912452538299801f }, { 0.463529807851185f, 0.886081326534672f },
	{ -0.962925769084928f, -0.269766497608949f }, { 0.744285209959416f, 0.66786190656128f }, { -0.691027420259623f, 0.722828544296177f }, { 0.981612661017864f, 0.190883691627725f }, { 0.928340009081787f, 0.371732198683444f }, { -0.120562843572988f, 0.992705696946278f }, { 0.789437446513116f, -0.61383101749818f }, { 0.999774655712189f, -0.0212282310985648f },
	{ -0.902267580211854f, 0.431176545858708f }, { -0.912180652347305f, -0.4097883081339f }, { -0.770294485489921f, -0.637688329533965f }, { 0.20063205075057f, 0.979666667908846f }, { -0.982785937329741f, -0.184747940142514f }, { 0.857295252061123f, -0.514825068147866f }, { -0.6880675701609f, -0.725646621223357f }, { 0.703885918434739f, -0.710313039320893f },
	{ 0.80736694412922f, -0.590049673779628f }, { 0.501306939228223f, -0.865269526033149f }, { 0.994382489412099f, -0.105846420584718f }, { 0.496494368044017f, -0.868039942917705f }, { 0.077642279257408f, -0.996981281906393f }, { 0.951970808735996f, -0.30618879684687f }, { -0.761381916275718f, -0.648303615267041f }, { 0.925704511866975f, 0.378247480770363f },
	{ 0.307462004306155f, 0.951560358520699f }, { -0.722833511616144f, -0.6910222243059f }, { 0.365487416741135f, -0.930816280585966f }, { -0.452581511359919f, 0.891723037481466f }, { -0.696052038963733f, -0.717991336336609f }, { -0.731589205376628f, -0.681745725748533f }, { -0.584030912612065f, 0.811731416857521f }, { -0.622817071437575f, -0.782367493909303f },
	{ -0.250124556053565f, -0.968213667771224f }, { -0.972374793807189f, -0.233425063710878f }, { -0.970811073944879f, 0.239845489234194f }, { 0.972096169972212f, -0.234582685476477f }, { -0.56398693111627f, -0.825783713529185f }, { -0.697050386134155f, 0.717022146931478f }, { -0.0346220968223854f, -0.999400475490992f }, { -0.218763172462792f, -0.975777984161364f },
	{ -0.526228595935678f, 0.850343145335791f }, { 0.878475471267297f, 0.477787448957902f }, { -0.543258510315468f, 0.839565477476188f }, { -0.424638392098636f, 0.905363040970795f }, { -0.511241626148254f, -0.859437024855975f }, { 0.310536598007565f, -0.950561424263518f }, { 0.647207900842245f, 0.762313539881967f }, { -0.998374197564832f, 0.0569996634795082f },
	{ -0.384499699032222f, 0.923125116895933f }, { 0.793017652527103f, -0.609198656252953f }, { -0.108016962369769f, 0.994149051118799f }, { -0.931126682943364f, 0.364695901143526f }, { -0.801286360381044f, -0.598281011454734f }, { 0.875902620980454f, -0.482487925817394f }, { -0.731473336626206f, 0.681870044660216f }, { -0.315759562725525f, -0.948839237461956f },
	{ -0.0770741115938651f, -0.997025366438596f }, { -0.822418334736048f, 0.568883188967635f }, { -0.998852401248829f, -0.0478944727442276f }, { 0.996841343178929f, -0.0794187416749304f }, { -0.632437179039341f, 0.774611654036241f }, { 0.719989390873874f, 0.693985069745068f }, { 0.99256596306396f, -0.121707883750037f }, { 0.851153933233715f, -0.524916166583558f },
	{ 0.952866133004913f, 0.303391055524489f }, { 0.983070281370671f, 0.183228878416556f }, { 0.751614346163695f, 0.659602815822462f }, { 0.549915829679874f, 0.83522007894177f }, { 0.529779603383605f, 0.8481353499523f }, { -0.738299650910558f, -0.67447285005799f }, { -0.888225309084572f, -0.459408097775406f }, { 0.69138401830353f, 0.722487466489534f },
	{ 0.895582660271765f, -0.4448951546382f }, { -0.823764839572624f, -0.566931644101728f }, { 0.481527438369519f, 0.876431016165727f }, { -0.393245292146023f, 0.9194335974963f }, { 0.511430719572624f, 0.859324513252955f }, { 0.709782009015835f, 0.704421393540433f }, { -0.123429256704187f, -0.992353373848979f }, { -0.796333188996483f, -0.60485820826264f },
};

static const float CELLULAR3D_LUT[][3] =
{
	{ -0.0754560603505074f, -0.352466298044147f, 0.235267278808342f }, { 0.375595337603153f, 0.231008132619556f, 0.0676738115920836f }, { -0.117712754267955f, 0.118823977675711f, 0.383220995235334f }, { -0.315022593984555f, -0.356826861858672f, 0.14429057112708f }, { 0.278226241297412f, -0.0824907503739393f, 0.0319716918006141f }, { 0.0721684409910568f, -0.0568065516303533f, -0.270396222381411f }, { -0.188642405575107f, 0.426286802128244f, -0.0997959961417977f }, { -0.21241450198315f, -0.156988971972095f, -0.371816039814609f },
	{ 0.0863582411916157f, 0.247123671654167f, -0.178732678014738f }, { -0.316057297392795f, -0.166683643723161f, -0.0611778223515034f }, { 0.328289724658807f, -0.247873201332817f, 0.0327134144703831f }, { 0.298161327325315f, 0.157043311120146f, -0.194787277619172f }, { 0.235578213651412f, -0.435245262589905f, -0.0422642484955862f }, { 0.327685758031643f, 0.241172355667957f, -0.207969548732154f }, { 0.00871052597199329f, 0.443412172727963f, -0.223881734853918f }, { -0.327815963122739f, -0.0632251381117975f, 0.0638698032894591f },
	{ 0.171293757904134f, -0.268967805310664f, 0.247330179961144f }, { -0.0949972350817184f, 0.063004943044643f, 0.294697968547845f }, { -0.0300170884515747f, -0.246318276945069f, -0.352747202100628f }, { -0.311656463135497f, 0.251926029121401f, -0.0149343564869993f }, { 0.0967990124710062f, -0.0232670198658895f, 0.411444409421758f }, { 0.171471713858107f, 0.34757034412655f, 0.308498108582644f }, { -0.226321846928427f, 0.0150474907816183f, -0.28139906987385f }, { 0.31642670441849f, -0.213204067384848f, -0.134793324142343f },
	{ -0.153080406416659f, -0.0708935401097545f, -0.374335538114601f }, { -0.141898142497496f, 0.396109169772019f, 0.217791125319443f }, { 0.0705297169419404f, -0.129260274971251f, 0.406859211329066f }, { 0.251810227220121f, 0.124949974348436f, -0.393553355584399f }, { -0.0368495944166345f, 0.241600973547733f, 0.148996628567347f }, { 0.386176272686462f, 0.0704541941317958f, 0.282892824561693f }, { -0.448707875225182f, -0.211852236277489f, -0.0593266252597142f }, { 0.26362413360482f, 0.121776945503026f, 0.400589609531262f },
	{ 0.0356172105184771f, -0.0694961844311607f, 0.207096739368625f }, { 0.0220676410856254f, -0.243509045746833f, -0.346155427302331f }, { -0.332850454243997f, -0.273747394478838f, -0.22048981878446f }, { -0.0192534015774575f, 0.274761909811407f, 0.0538736339590546f }, { 0.165317580671615f, -0.17816927829344f, 0.111506805650966f }, { 0.160011063093249f, -0.189988000083815f, -0.123927439752988f }, { -0.0556742716525043f, -0.145924001539992f, 0.255437545994726f }, { -0.0756379835094876f, 0.117828081134182f, -0.0120650913993298f },
	{ -0.197210049133133f, 0.366845948861914f, -0.069149027078396f }, { -0.327754728775996f, -0.150084029241845f, 0.145075072942995f }, { 0.161237889571005f, -0.243941829192892f, -0.175439034288131f }, { -0.309384192990048f, 0.073277812505501f, 0.11883287100647f }, { 0.0232216051376899f, -0.108987914593452f, 0.0761115614757536f }, { -0.347002244980896f, -0.0790758856307948f, -0.292676467340568f }, { 0.103534060321088f, -0.203205137065946f, 0.118248046232412f }, { -0.179220531222376f, -0.344376091077383f, 0.264564404302929f },
	{ -0.105623452834155f, 0.172260765651461f, 0.286525292886974f }, { 0.274615478686034f, 0.39708151176951f, 0.108857497420682f }, { 0.0272308304879481f, -0.29857786875525f, 0.218901052935987f }, { 0.181150683549163f, -0.0390599930595309f, 0.0949206494787788f }, { -0.00544027941931291f, 0.258695402688113f, 0.159206235697394f }, { 0.14666780165587f, -0.295910619616463f, -0.141165960124873f }, { -0.426587975388305f, 0.0760382887605349f, 0.0472664490532966f }, { -0.0152659279961116f, 0.180812473889749f, 0.259829082596259f },
	{ 0.352340969489831f, 0.0949483549802f, -0.177789296750313f }, { -0.0905631767650262f, 0.263643399485011f, -0.177426671881535f }, { -0.0970863948176078f, -0.33023504648773f, -0.285310888372764f }, { 0.0979689417894761f, 0.1887091910561f, 0.433033843855928f }, { -0.326971547677627f, -0.249788070497878f, -0.234005939695248f }, { -0.325347232785791f, -0.316738721236934f, -0.20152323790929f }, { 0.218137901142078f, 0.339775203104837f, 0.136861866669955f }, { 0.00486092295852336f, 0.152424623596169f, -0.207909928163038f },
	{ -0.0224237596869308f, -0.111900496204799f, -0.418651994989208f }, { -0.320527275160396f, 0.0837356323613371f, -0.0780152086437003f }, { 0.0280545571637402f, 0.407068362508662f, -0.232043213598857f }, { 0.173273195782102f, 0.032319521677456f, 0.251161338290762f }, { -0.127089097779856f, -0.130136356191262f, 0.298162430252907f }, { 0.428700245699538f, 0.0346044966001166f, -0.0204478035247239f }, { 0.123276076546935f, -0.176201654967961f, 0.140866137138884f }, { -0.167754642481773f, -0.16902730786879f, 0.199609554336224f },
	{ 0.223309910629808f, -0.0669686697938046f, -0.130671553077962f }, { -0.287382586145988f, -0.29283231663167f, 0.113706916565294f }, { 0.261284336575583f, -0.0802855040763278f, 0.324631782222548f }, { 0.129138154866895f, -0.180303542151919f, -0.0542081960881317f }, { -0.00322524201704166f, -0.243319454466774f, -0.362203650983436f }, { -0.268885359697498f, -0.313746527308031f, -0.0862470339408644f }, { 0.268103596101711f, -0.0377728764616946f, 0.00828001824924351f }, { 0.201924589190448f, 0.252778778826486f, 0.169097036415934f },
	{ 0.0546812195057308f, 0.0800291713727608f, 0.0127197209798533f }, { -0.329478417276474f, -0.252260304381621f, 0.0811441199641992f }, { 0.0091774761997484f, -0.28113417626388f, 0.237416782049565f }, { 0.0116337713075201f, -0.0188369389512223f, 0.480322379472401f }, { -0.305467029064262f, 0.341714339313991f, 0.173830325450309f }, { 0.000413372001765056f, 0.11516372089457f, -0.0474483021807772f }, { 0.00146930779539023f, 0.174098694109033f, 0.187423873199821f }, { -0.101880886099702f, -0.158549810567217f, -0.455340710792498f },
	{ -0.0195640688989295f, 0.0308029895294849f, -0.00872802775024206f }, { -0.063948607587152f, -0.171039592434666f, -0.0894551497004384f }, { -0.0545760624153979f, 0.464803465232108f, 0.124693473073799f }, { 0.3502937004872f, -0.199728724661434f, -0.141569473253716f }, { 0.0480124973209703f, 0.0425320941310352f, 0.0576268391267263f }, { 0.0700554646300197f, -0.120177701533213f, 0.362939649754906f }, { -0.0888968497938477f, -0.0442641180954902f, 0.166977335738641f }, { 0.0697174979695231f, 0.0644477521727814f, -0.172231794817971f },
	{ 0.222483000892674f, 0.194106396048384f, 0.316456746402756f }, { -0.170135444019886f, -0.00324314723026486f, -0.165167042724334f }, { 0.188254592483392f, -0.127943637635902f, 0.289532792150166f }, { 0.0321017602916118f, 0.348205815674701f, -0.0423729539991641f }, { 0.0507248787487231f, -0.253204804600527f, -0.0490837360518831f }, { 0.111313377002407f, 0.349362368224835f, 0.334910365753693f }, { 0.257937106004627f, 0.105411965585877f, -0.361711729374542f }, { 0.0512900731488198f, -0.229549656856243f, 0.257417925577553f },
	{ -0.0381335012121889f, -0.330155168592936f, -0.333446175022896f }, { 0.110047540932941f, 0.43508905862244f, 0.0277996810151547f }, { 0.363155663971144f, 0.0668365347413614f, -0.229422247703535f }, { 0.30237496486279f, 0.181161839632804f, -0.221745064022372f }, { -0.175531221684405f, 0.118314189158817f, -0.0946833041061461f }, { -0.0470680223650999f, 0.0792855222829776f, 0.300601076715962f }, { 0.467711149632443f, -0.0521985142563184f, -0.00732893624357533f }, { -0.486423326745718f, 0.110947174674555f, 0.0263696605073731f },
	{ 0.0673719962838721f, -0.0778641524623683f, -0.467765990824302f }, { -0.165167932030356f, 0.0892720815465723f, -0.453272099337044f }, { 0.333578699113336f, -0.0297017005530308f, -0.0593905771419292f }, { 0.293288259258728f, 0.329403857510877f, -0.0759052841271396f }, { -0.204973281426423f, -0.309881996850931f, -0.150366438202898f }, { -0.206856274245894f, -0.179009067617496f, 0.221566961074757f }, { 0.255178679781575f, 0.153287028194758f, 0.00198543730535206f }, { -0.0636156864091478f, -0.0803024091741419f, 0.0530485248550313f },
	{ 0.0751579446945424f, 0.182907776192345f, 0.18834028318176f }, { -0.468324198184296f, -0.115280697354904f, 0.0483896328016261f }, { 0.0345510640405808f, 0.386355307366794f, 0.151812147023893f }, { 0.365574769745067f, -0.00837337833290497f, -0.18850992962134f }, { -0.0806692553709122f, 0.0415279784091643f, 0.17127732820122f }, { -0.118467082405899f, -0.0597561635624523f, 0.317959096715079f }, { -0.076768269845923f, -0.0144695926151897f, -0.15893078666523f }, { -0.248815876390639f, -0.387878624851675f, -0.0522421374813546f },
};

static const float CELLULAR2D_LUT[][2] =
{
	{ 0.250708038153379f, 0.249427694225972f }, { 0.0869437515459609f, 0.184749552136559f }, { -0.0413046810386655f, 0.403981043609444f }, { -0.0293907403944378f, 0.49913076795134f }, { -0.315196544673176f, 0.112131089257973f }, { 0.284986509052738f, -0.239847923263601f }, { -0.0546095496331694f, -0.387046123842226f }, { -0.455916077222658f, -0.0285751529349881f },
	{ -0.159697602772812f, -0.069715028041617f }, { -0.13499310031726f, -0.24544360590384f }, { 0.0712784658236382f, -0.210509752150429f }, { -0.183139799640577f, 0.0989616462898892f }, { -0.120954871197088f, -0.404416525393099f }, { 0.0397020774694894f, -0.332051780499794f }, { 0.156583517215517f, -0.355997670354414f }, { -0.118253736644093f, -0.273834274561332f },
	{ 0.407280633332697f, 0.0695704319921797f }, { -0.181395165743625f, -0.0360988318776937f }, { 0.149517494831831f, 0.275252778735439f }, { -0.239680212428189f, -0.296006529252734f }, { 0.0648980428870777f, -0.165592673711567f }, { -0.164235060392619f, -0.044152747040758f }, { -0.0880929686013205f, 0.319070946524584f }, { -0.359118900783392f, -0.145231031891457f },
	{ 0.13904415334069f, 0.115456824951353f }, { 0.0842991474059002f, 0.0604465759876108f }, { -0.353890154574729f, 0.0563377224444608f }, { -0.191548757651777f, 0.458666569079093f }, { -0.0305852649733824f, -0.103294981589093f }, { -0.244249558051389f, -0.184215340423203f }, { -0.335508375435451f, 0.366044689290556f }, { -0.0842977163909816f, -0.181691541539155f },
	{ -0.194574831896163f, -0.0360977050226033f }, { -0.0136275832633322f, 0.348855027149362f }, { 0.112779750419581f, 0.250740618802603f }, { 0.446016898314568f, 0.19375271707891f }, { 0.370298098312872f, -0.308060032847868f }, { -0.174031950246891f, 0.068370776312583f }, { -0.0320673407373619f, -0.490638717459424f }, { 0.277163688315855f, 0.12127656301314f },
	{ 0.0568558134728565f, 0.350239706769654f }, { 0.205869692362488f, -0.400914200219679f }, { -0.391075780729104f, 0.239049951016082f }, { 0.0898368903641186f, 0.396970664249824f }, { -0.12708545544806f, 0.205550073947438f }, { 0.329713608183662f, -0.00124387983313534f }, { 0.215101309878185f, 0.31230482220907f }, { -0.299990667492553f, 0.0362774842315264f },
	{ -0.162024884165002f, 0.390269354299181f }, { 0.247175458660869f, -0.164649461140494f }, { -0.00702116345848802f, 0.177588576697459f }, { -0.0535304504389743f, -0.40845998572649f }, { 0.0145856109573733f, 0.382905331923157f }, { 0.216280639152196f, -0.209660172189405f }, { 0.402533050670213f, 0.162391078948541f }, { -0.365399410561553f, -0.110910594428755f },
	{ 0.174770668216721f, -0.397793366833591f }, { 0.32230859429012f, -0.137029006198646f }, { 0.171029762566206f, -0.381445776782064f }, { -0.229611775033244f, 0.0104655318145362f }, { -0.293902727481095f, -0.373532221230389f }, { 0.285221677418125f, -0.296232913639187f }, { -0.28269015083746f, 0.403270257987613f }, { -0.43086572953841f, -0.179317972362171f },
	{ -0.310057947802406f, -0.0787640260872092f }, { 0.0533765298216697f, 0.440202724974886f }, { -0.354033675325863f, 0.0698196861581185f }, { 0.311115679250857f, -0.129663260096312f }, { 0.229255390402563f, -0.328758027086313f }, { -0.33536302092319f, -0.290805878133609f }, { -0.384663256926429f, 0.238445759121866f }, { 0.281520545158111f, 0.264852699142123f },
	{ -0.218357566260313f, 0.0793706065412086f }, { 0.164980332762834f, 0.182041388247544f }, { 0.307207781894971f, -0.22816860870366f }, { -0.454503892591875f, 0.0592878003115745f }, { -0.0894050246174167f, -0.418329169674f }, { -0.276089185505125f, 0.0439845273659423f }, { -0.151684626764266f, -0.0037583472744015f }, { 0.133104875185567f, 0.185590164995452f },
	{ -0.102966431104062f, -0.433484981926515f }, { 0.131172549940418f, 0.278916720062804f }, { 0.0938441203621891f, 0.378164201175125f }, { 0.390368899361443f, 0.0258977574673016f }, { -0.304185462809122f, -0.220404718569479f }, { 0.041114945526263f, 0.0231437900813286f }, { -0.0553679533766611f, 0.109770312957138f }, { -0.153408636511854f, -0.259551360860073f },
	{ 0.18314747642386f, 0.346041366704221f }, { -0.202409229916045f, 0.0830509156789105f }, { 0.00263870789986387f, -0.14989084637648f }, { -0.0174869839365028f, -0.0973506129991467f }, { -0.335359236494802f, -0.0804404327143762f }, { -0.241126779112638f, -0.0757387480664328f }, { 0.261018611568062f, -0.0492869133053188f }, { -0.0959999647631716f, 0.222694380942215f },
	{ 0.299431284684768f, 0.106521457979214f }, { 0.227637867405222f, -0.174455746888093f }, { 0.0922702482664376f, 0.26819649456602f }, { -0.151399312307839f, -0.125974097818691f }, { 0.108938078293079f, -0.304856700693976f }, { -0.438854244630266f, -0.132330505223942f }, { 0.0717952564882181f, 0.275888210440627f }, { -0.215751231440234f, 0.0355311465640098f },
	{ 0.422176755226945f, -0.0189335471371869f }, { -0.408859832848213f, 0.000537910856484469f }, { -0.0362598525704807f, 0.357413669332284f }, { -0.28032466328989f, 0.347911002432735f }, { 0.198710871738271f, 0.0601322001820659f }, { 0.285019264549449f, -0.298882702144618f }, { -0.0780288055851716f, 0.441572196343895f }, { 0.15900180964612f, 0.449105031972222f },
	{ 0.203387295255816f, 0.0755020611275794f }, { 0.466447410709773f, 0.0154577407226987f }, { 0.09642323208626f, 0.448221598304089f }, { -0.147868203532494f, -0.0586292019305197f }, { 0.32832047650105f, -0.0852312055816367f }, { -0.229855755874368f, -0.229760903875133f }, { 0.133073203870081f, 0.474537707771751f }, { 0.158309714495696f, 0.366021857483007f },
	{ 0.132325770252795f, 0.239780173970358f }, { 0.0390928599864625f, -0.244597408317102f }, { 0.0343482304430441f, 0.232382438149273f }, { 0.15455940326916f, -0.237057253070687f }, { -0.176575322299199f, 0.422823548490547f }, { 0.209170093404748f, -0.385858241380788f }, { 0.020364957428845f, 0.386396490846172f }, { 0.0812228894854148f, 0.189603055294904f },
};

static const float CELLULAR3D_HQ_LUT[][3] =
{
	{ 0.262932373665163f, 0.153551471449999f, -0.291969634275151f }, { -0.708609143985588f, -0.514998048421491f, 0.468159964816915f }, { 0.0551260170047587f, -0.103445903417864f, 0.376255883682633f }, { 0.653683775467831f, -0.209613833397724f, 0.474524557390902f }, { -0.767495075439816f, -0.277635268454571f, -0.499126852976707f }, { 0.0517033820553658f, -0.450874096824908f, 0.259859999016614f }, { -0.328914949209403f, 0.315228929382438f, -0.149017858088919f }, { 0.0702011812650336f, -0.193692109698035f, -0.304651622963667f },
	{ 0.115919086058792f, -0.751681327447624f, -0.0578792834991346f }, { 0.105405347691047f, 0.596411986507577f, -0.33931739668656f }, { -0.106893530709245f, 0.280618421509181f, -0.832043100155617f }, { -0.0654181807636467f, -0.817494727882153f, 0.527423134166989f }, { -0.66607712436171f, 0.387833863130976f, -0.311127054266423f }, { 0.222366128263935f, 0.434069356849451f, 0.00109203594106155f }, { -0.582103888739791f, -0.403986953332572f, -0.165705027911859f }, { 0.147627538078114f, 0.288260167875865f, -0.883529956736502f },
	{ -0.402250371905059f, 0.832656383831385f, 0.186741768838311f }, { 0.473464736343465f, -0.679703118275789f, -0.40077691322837f }, { -0.035237830398541f, -0.419372284464907f, -0.477838593663681f }, { -0.430487584231229f, -0.290911667411263f, 0.505812452597545f }, { 0.530931074100062f, -0.650579753053343f, 0.515492249408879f }, { 0.220881415711242f, -0.469097215411346f, 0.157019606755508f }, { 0.27675389355964f, 0.901383931545492f, 0.231732886094137f }, { -0.014879042790529f, 0.811750856488725f, -0.434024472541077f },
	{ 0.538380603929312f, -0.21066468611799f, -0.724148505984583f }, { -0.121759133523113f, -0.793801224166494f, -0.132237392467051f }, { 0.117840222824295f, -0.355374228588378f, 0.124682929359946f }, { 0.688176141934959f, 0.521187417030148f, 0.345118407050836f }, { 0.407086542191789f, 0.732926996979246f, -0.209010702506625f }, { 0.32581242531042f, 0.558528412538481f, 0.71158552609818f }, { -0.555004950694707f, 0.516168523403744f, -0.240804448574935f }, { -0.904859502439036f, 0.0743969389263999f, 0.104715802991092f },
	{ 0.073325689986677f, -0.782036330994516f, -0.443786517587736f }, { -0.459555572527443f, 0.441887114861482f, -0.698441137965975f }, { -0.289668589713193f, 0.136769868484689f, -0.151654754992696f }, { 0.0237640444705514f, -0.269938670705644f, 0.607147708571096f }, { 0.67380601738027f, -0.309629481481464f, -0.460400343102835f }, { -0.397564983510291f, -0.673833834620159f, -0.0268946039774807f }, { 0.0462694151743761f, -0.45226005741164f, 0.49630646089289f }, { 0.866762371975284f, -0.295718510182752f, 0.0149819193522451f },
	{ 0.2029001303841f, -0.860056357816732f, -0.393452982216838f }, { -0.0998122338298171f, 0.294931944597187f, 0.178736158605963f }, { 0.875395522526907f, -0.0825672831515398f, -0.460278189186178f }, { 0.383915619327118f, 0.518552179491168f, 0.671760904200527f }, { -0.61311255399366f, 0.322849149919877f, 0.17618402803691f }, { -0.234437862015477f, -0.627320988866885f, -0.265500329226805f }, { 0.416683509524642f, -0.140340238885287f, -0.68350172163144f }, { -0.489865936729821f, 0.304547764633088f, -0.577657734402201f },
	{ 0.015759591666709f, -0.594032257039018f, 0.463159994056296f }, { 0.439192390921798f, -0.336126120843506f, -0.422737546477267f }, { 0.71744341454758f, -0.00698408270005091f, 0.499074258720097f }, { 0.252743757804593f, 0.0784696789857056f, -0.926006060991399f }, { 0.0956254270548202f, 0.884658796043882f, -0.0114316642871644f }, { -0.216903755102342f, -0.43309359670365f, 0.793361004002833f }, { 0.52089409573502f, -0.19360022054141f, 0.38119863467235f }, { 0.570874593801336f, -0.741499682901108f, 0.195220233022693f },
	{ 0.230116054141979f, -0.811711249775019f, -0.159575177040295f }, { -0.52123457383871f, 0.608624936295915f, 0.0449283489961014f }, { 0.127265509406933f, 0.112318538538559f, 0.922257260069714f }, { 0.0435935031911137f, 0.115754498653675f, 0.391429386205104f }, { 0.0102467351406248f, 0.431649787010987f, -0.398787878721233f }, { -0.458384483848666f, -0.427369330684921f, -0.587018487633901f }, { -0.483950934055113f, 0.417657401116388f, -0.491178601954959f }, { 0.236858447246911f, -0.458162993791689f, -0.263844368869653f },
	{ -0.340861098779621f, -0.295116464376117f, -0.000253402065530928f }, { -0.17073745544894f, -0.450108815269867f, -0.680400290523957f }, { 0.669276083671338f, 0.111032563569802f, -0.514052787961861f }, { 0.450325970818041f, -0.723645973102069f, -0.509385455376786f }, { 0.40546085170602f, 0.298810476349315f, 0.304299653922338f }, { -0.35105196810049f, 0.00378437413660104f, -0.164198941209194f }, { 0.15837401340184f, -0.58760716162567f, -0.213442574113378f }, { 0.504589866318021f, 0.770581155351702f, 0.371072038157382f },
	{ -0.569917417360092f, 0.559090216133928f, 0.160062597545231f }, { 0.160070848322477f, -0.0395876689862924f, -0.532067587816388f }, { -0.0162490333694416f, -0.166606441887101f, 0.59031696309757f }, { 0.207454135965524f, -0.0260188121959155f, -0.0599975464877465f }, { 0.383393993979441f, 0.663436168489971f, -0.157384854720779f }, { 0.350733297272835f, 0.316730570942483f, 0.577922336088516f }, { -0.570698620220757f, -0.175181454934868f, -0.480423100007302f }, { 0.245776347749264f, 0.427276333132852f, -0.688657145411795f },
	{ 0.00224144344693711f, 0.00486875393689057f, 0.188630013244312f }, { -0.22320226271512f, 0.923078828186733f, 0.296394027890566f }, { -0.449367472675937f, 0.269408537364126f, -0.390764128147193f }, { -0.394689368226122f, 0.142154313149621f, 0.800140356276413f }, { -0.230385706804416f, 0.485731274665201f, -0.492797919049728f }, { -0.380864075462633f, 0.467568868467785f, -0.603299465591556f }, { 0.548776278357963f, -0.537839005994549f, 0.397971844121229f }, { -0.275174053701755f, -0.391807088222938f, 0.480636386049214f },
	{ 0.284656397891213f, 0.0581184553813519f, -0.841053249656449f }, { -0.386828737091746f, -0.235379652741697f, 0.263850790355352f }, { 0.143987287842321f, 0.755274882908506f, 0.422080517050494f }, { 0.000470724533063294f, -0.0473107320549859f, 0.0724971409709871f }, { 0.103391561905551f, -0.917431070027245f, 0.119939586652184f }, { -0.0457566323054017f, 0.0442951353165546f, -0.535182076224448f }, { -0.641716861271846f, -0.3611219930046f, -0.459985999588059f }, { -0.317723907645648f, 0.473887486072258f, -0.0815424940022806f },
	{ -0.150956959580923f, -0.898069335729604f, -0.0749817012181173f }, { -0.0694370536183593f, -0.809740700114329f, -0.524988425169715f }, { 0.0183640251609041f, 0.00284625229352731f, 0.0961110706401243f }, { -0.620624836946168f, -0.562868042878287f, -0.205118401290757f }, { 0.408689589075526f, -0.501262203450612f, 0.277695531087804f }, { 0.186931149366143f, -0.663548375891839f, 0.355733357372202f }, { -0.141842957269254f, 0.120921681621546f, -0.671084668688337f }, { -0.264873428039199f, 0.283796022182013f, 0.264201694496239f },
	{ 0.845910171349198f, 0.115571332098421f, -0.0593372087567183f }, { 0.506886450146619f, 0.58255219714823f, 0.509438518167282f }, { 0.511438935024482f, 0.313488364222524f, -0.134014278985907f }, { 0.335472286345643f, 0.0563688323103442f, 0.371470647626975f }, { 0.762365131690096f, 0.504192783610985f, -0.235338237516637f }, { 0.620629080010914f, 0.164210058630659f, -0.506830471222315f }, { 0.915246129596587f, -0.399684515794182f, 0.0460348647894813f }, { -0.443640166123101f, -0.411333818521207f, -0.228855711069713f },
	{ -0.0891555675181099f, 0.424254955210822f, 0.705840028112787f }, { 0.374854327358691f, -0.901486549279051f, -0.177736019017455f }, { 0.907817968660537f, -0.0159931756505556f, -0.148322983300674f }, { 0.414043522473934f, 0.0396720299759967f, -0.154121976568144f }, { -0.215641489200622f, -0.863190025563005f, 0.282817477121766f }, { -0.493384676399966f, -0.486965227586759f, -0.277041556868121f }, { -0.145413267930942f, 0.367234756450644f, 0.255892208595349f }, { 0.208240177121022f, 0.0679624055226822f, -0.11065853298164f },
	{ -0.783340968157716f, 0.494544372295232f, 0.0986476741588405f }, { -0.465821052204292f, -0.254657063635933f, -0.203297244054974f }, { 0.182339141215468f, -0.599744300940732f, 0.149427656165992f }, { 0.255210939940937f, -0.637324227353845f, 0.356059851123357f }, { 0.069708224081209f, 0.153461716043562f, 0.890917610812324f }, { -0.672197456743714f, 0.0338542979125953f, 0.516046304990767f }, { 0.0796552321449462f, 0.423954290457488f, -0.273956291079693f }, { 0.237432509436643f, -0.790497730916185f, -0.124872981867872f },
};

static const float CELLULAR2D_HQ_LUT[][2] =
{
	{ 0.501416076306759f, 0.498855388451945f }, { 0.173887503091922f, 0.369499104273119f }, { -0.0826093620773309f, 0.807962087218888f }, { -0.0587814807888756f, 0.998261535902679f }, { -0.630393089346351f, 0.224262178515945f }, { 0.569973018105476f, -0.479695846527202f }, { -0.109219099266339f, -0.774092247684452f }, { -0.911832154445317f, -0.0571503058699763f },
	{ -0.319395205545624f, -0.139430056083234f }, { -0.26998620063452f, -0.490887211807679f }, { 0.142556931647276f, -0.421019504300857f }, { -0.366279599281153f, 0.197923292579778f }, { -0.241909742394175f, -0.808833050786198f }, { 0.0794041549389788f, -0.664103560999588f }, { 0.313167034431034f, -0.711995340708829f }, { -0.236507473288186f, -0.547668549122665f },
	{ 0.814561266665395f, 0.139140863984359f }, { -0.362790331487249f, -0.0721976637553874f }, { 0.299034989663662f, 0.550505557470879f }, { -0.479360424856379f, -0.592013058505467f }, { 0.129796085774155f, -0.331185347423135f }, { -0.328470120785237f, -0.088305494081516f }, { -0.176185937202641f, 0.638141893049167f }, { -0.718237801566785f, -0.290462063782915f },
	{ 0.278088306681379f, 0.230913649902705f }, { 0.1685982948118f, 0.120893151975222f }, { -0.707780309149458f, 0.112675444888922f }, { -0.383097515303555f, 0.917333138158185f }, { -0.0611705299467649f, -0.206589963178185f }, { -0.488499116102778f, -0.368430680846406f }, { -0.671016750870902f, 0.732089378581113f }, { -0.168595432781963f, -0.36338308307831f },
	{ -0.389149663792326f, -0.0721954100452067f }, { -0.0272551665266645f, 0.697710054298724f }, { 0.225559500839161f, 0.501481237605205f }, { 0.892033796629135f, 0.38750543415782f }, { 0.740596196625744f, -0.616120065695737f }, { -0.348063900493782f, 0.136741552625166f }, { -0.0641346814747239f, -0.981277434918847f }, { 0.55432737663171f, 0.242553126026281f },
	{ 0.113711626945713f, 0.700479413539308f }, { 0.411739384724977f, -0.801828400439358f }, { -0.782151561458208f, 0.478099902032164f }, { 0.179673780728237f, 0.793941328499648f }, { -0.25417091089612f, 0.411100147894876f }, { 0.659427216367324f, -0.00248775966627068f }, { 0.43020261975637f, 0.624609644418139f }, { -0.599981334985107f, 0.0725549684630529f },
	{ -0.324049768330005f, 0.780538708598361f }, { 0.494350917321738f, -0.329298922280988f }, { -0.014042326916976f, 0.355177153394918f }, { -0.107060900877949f, -0.81691997145298f }, { 0.0291712219147466f, 0.765810663846315f }, { 0.432561278304393f, -0.41932034437881f }, { 0.805066101340427f, 0.324782157897081f }, { -0.730798821123107f, -0.22182118885751f },
	{ 0.349541336433442f, -0.795586733667181f }, { 0.64461718858024f, -0.274058012397292f }, { 0.342059525132412f, -0.762891553564127f }, { -0.459223550066487f, 0.0209310636290725f }, { -0.58780545496219f, -0.747064442460778f }, { 0.570443354836249f, -0.592465827278374f }, { -0.56538030167492f, 0.806540515975226f }, { -0.861731459076821f, -0.358635944724342f },
	{ -0.620115895604812f, -0.157528052174418f }, { 0.106753059643339f, 0.880405449949772f }, { -0.708067350651726f, 0.139639372316237f }, { 0.622231358501715f, -0.259326520192625f }, { 0.458510780805126f, -0.657516054172625f }, { -0.67072604184638f, -0.581611756267217f }, { -0.769326513852858f, 0.476891518243733f }, { 0.563041090316222f, 0.529705398284246f },
	{ -0.436715132520625f, 0.158741213082417f }, { 0.329960665525668f, 0.364082776495089f }, { 0.614415563789942f, -0.45633721740732f }, { -0.909007785183749f, 0.118575600623149f }, { -0.178810049234833f, -0.836658339348f }, { -0.55217837101025f, 0.0879690547318845f }, { -0.303369253528533f, -0.00751669454880299f }, { 0.266209750371134f, 0.371180329990904f },
	{ -0.205932862208124f, -0.866969963853029f }, { 0.262345099880836f, 0.557833440125609f }, { 0.187688240724378f, 0.75632840235025f }, { 0.780737798722887f, 0.0517955149346032f }, { -0.608370925618243f, -0.440809437138958f }, { 0.0822298910525261f, 0.0462875801626572f }, { -0.110735906753322f, 0.219540625914276f }, { -0.306817273023707f, -0.519102721720146f },
	{ 0.366294952847719f, 0.692082733408441f }, { -0.40481845983209f, 0.166101831357821f }, { 0.00527741579972774f, -0.299781692752959f }, { -0.0349739678730057f, -0.194701225998293f }, { -0.670718472989604f, -0.160880865428752f }, { -0.482253558225276f, -0.151477496132866f }, { 0.522037223136125f, -0.0985738266106375f }, { -0.191999929526343f, 0.445388761884429f },
	{ 0.598862569369537f, 0.213042915958428f }, { 0.455275734810445f, -0.348911493776186f }, { 0.184540496532875f, 0.536392989132039f }, { -0.302798624615678f, -0.251948195637381f }, { 0.217876156586158f, -0.609713401387953f }, { -0.877708489260532f, -0.264661010447884f }, { 0.143590512976436f, 0.551776420881253f }, { -0.431502462880468f, 0.0710622931280196f },
	{ 0.84435351045389f, -0.0378670942743737f }, { -0.817719665696427f, 0.00107582171296894f }, { -0.0725197051409614f, 0.714827338664568f }, { -0.56064932657978f, 0.695822004865471f }, { 0.397421743476542f, 0.120264400364132f }, { 0.570038529098898f, -0.597765404289235f }, { -0.156057611170343f, 0.88314439268779f }, { 0.31800361929224f, 0.898210063944443f },
	{ 0.406774590511633f, 0.151004122255159f }, { 0.932894821419546f, 0.0309154814453974f }, { 0.19284646417252f, 0.896443196608179f }, { -0.295736407064989f, -0.117258403861039f }, { 0.6566409530021f, -0.170462411163273f }, { -0.459711511748736f, -0.459521807750266f }, { 0.266146407740162f, 0.949075415543502f }, { 0.316619428991393f, 0.732043714966014f },
	{ 0.26465154050559f, 0.479560347940717f }, { 0.078185719972925f, -0.489194816634204f }, { 0.0686964608860883f, 0.464764876298545f }, { 0.309118806538319f, -0.474114506141374f }, { -0.353150644598397f, 0.845647096981094f }, { 0.418340186809496f, -0.771716482761576f }, { 0.0407299148576901f, 0.772792981692343f }, { 0.16244577897083f, 0.379206110589807f },

};

static int FastFloor(float f) { return (f >= 0.0f ? (int)f : (int)f - 1); }
static int FastRound(float f) { return (f >= 0.0f) ? (int)(f + 0.5f) : (int)(f - 0.5f); }
static float FastAbs(float f) { return (f >= 0.0f) ? f : -f; }
static int FastAbs(int i) { return (i > 0) ? i : -i; }
static float Lerp(float a, float b, float t) { return a + t * (b - a); }
static void LerpVector3(float* out, float* a, float* b, float t)
{
	out[0] = Lerp(a[0], b[0], t);
	out[1] = Lerp(a[1], b[1], t);
	out[2] = Lerp(a[2], b[2], t);
}

static float InterpHermiteFunc(float t) { return (t*t*(3 - 2 * t)); }
static float InterpQuinticFunc(float t) { return t*t*t*(t*(t * 6 - 15) + 10); }

// Hashing
#define X_PRIME 15485863
#define Y_PRIME 10057189
#define Z_PRIME 987391
#define W_PRIME 418493

inline int FastNoise::CoordLUTIndex(int seed, int x, int y, int z, int w)
{
	int hash = seed;
	hash ^= x;
	hash *= X_PRIME;
	hash ^= y;
	hash *= Y_PRIME;
	hash ^= z;
	hash *= Z_PRIME;
	hash ^= w;
	hash *= W_PRIME;
	hash ^= hash >> 16;

	return hash & LUT_MASK;
}

inline int FastNoise::CoordLUTIndex(int seed, int x, int y, int z)
{
	int hash = seed;
	hash ^= x;
	hash *= X_PRIME;
	hash ^= y;
	hash *= Y_PRIME;
	hash ^= z;
	hash *= Z_PRIME;
	hash ^= hash >> 16;

	return hash & LUT_MASK;
}

inline int FastNoise::CoordLUTIndex(int seed, int x, int y)
{
	int hash = seed;
	hash ^= x;
	hash *= X_PRIME;
	hash ^= y;
	hash *= Y_PRIME;
	hash ^= hash >> 16;

	return hash & LUT_MASK;
}

float FastNoise::GetNoise(float x, float y, float z)
{
	x *= m_frequency;
	y *= m_frequency;
	z *= m_frequency;

	switch (m_noiseType)
	{
	case FastNoise::NoiseType::Value:
		return _Value(m_seed, x, y, z);
	case FastNoise::NoiseType::ValueFractal:
		switch (m_fractalType)
		{
		case FastNoise::FBM:
			return _ValueFractalFBM(x, y, z);
		case FastNoise::Billow:
			return _ValueFractalBillow(x, y, z);
		case FastNoise::RigidMulti:
			return _ValueFractalRigidMulti(x, y, z);
		default:
			return 0.0f;
		}
	case FastNoise::NoiseType::Gradient:
		return _Gradient(m_seed, x, y, z);
	case FastNoise::NoiseType::GradientFractal:
		switch (m_fractalType)
		{
		case FastNoise::FBM:
			return _GradientFractalFBM(x, y, z);
		case FastNoise::Billow:
			return _GradientFractalBillow(x, y, z);
		case FastNoise::RigidMulti:
			return _GradientFractalRigidMulti(x, y, z);
		default:
			return 0.0f;
		}
	case FastNoise::NoiseType::Simplex:
		return _Simplex(m_seed, x, y, z);
	case FastNoise::NoiseType::SimplexFractal:
		switch (m_fractalType)
		{
		case FastNoise::FBM:
			return _SimplexFractalFBM(x, y, z);
		case FastNoise::Billow:
			return _SimplexFractalBillow(x, y, z);
		case FastNoise::RigidMulti:
			return _SimplexFractalRigidMulti(x, y, z);
		default:
			return 0.0f;
		}
	case FastNoise::NoiseType::Cellular:
		switch (m_cellularReturnType)
		{
		case Distance2Edge:
		case Distance2EdgeXValue:
		case Distance2EdgeSq:
		case Distance2EdgeSqXValue:
			return _Cellular2Edge(x, y, z);
		default:
			return _Cellular(x, y, z);
		}
	case FastNoise::NoiseType::CellularHQ:
		switch (m_cellularReturnType)
		{
		case Distance2Edge:
		case Distance2EdgeXValue:
		case Distance2EdgeSq:
		case Distance2EdgeSqXValue:
			return _Cellular2EdgeHQ(x, y, z);
		default:
			return _CellularHQ(x, y, z);
		}
	case FastNoise::NoiseType::WhiteNoise:
		return GetWhiteNoise(x, y, z);
	default:
		return 0.0f;
	}
}

float FastNoise::GetNoise(float x, float y)
{
	x *= m_frequency;
	y *= m_frequency;

	switch (m_noiseType)
	{
	case FastNoise::NoiseType::Value:
		return _Value(m_seed, x, y);
	case FastNoise::NoiseType::ValueFractal:
		switch (m_fractalType)
		{
		case FastNoise::FBM:
			return _ValueFractalFBM(x, y);
		case FastNoise::Billow:
			return _ValueFractalBillow(x, y);
		case FastNoise::RigidMulti:
			return _ValueFractalRigidMulti(x, y);
		default:
			return 0.0f;
		}
	case FastNoise::NoiseType::Gradient:
		return _Gradient(m_seed, x, y);
	case FastNoise::NoiseType::GradientFractal:
		switch (m_fractalType)
		{
		case FastNoise::FBM:
			return _GradientFractalFBM(x, y);
		case FastNoise::Billow:
			return _GradientFractalBillow(x, y);
		case FastNoise::RigidMulti:
			return _GradientFractalRigidMulti(x, y);
		default:
			return 0.0f;
		}
	case FastNoise::NoiseType::Simplex:
		return _Simplex(m_seed, x, y);
	case FastNoise::NoiseType::SimplexFractal:
		switch (m_fractalType)
		{
		case FastNoise::FBM:
			return _SimplexFractalFBM(x, y);
		case FastNoise::Billow:
			return _SimplexFractalBillow(x, y);
		case FastNoise::RigidMulti:
			return _SimplexFractalRigidMulti(x, y);
		default:
			return 0.0f;
		}
	case FastNoise::NoiseType::Cellular:
		switch (m_cellularReturnType)
		{
		case Distance2Edge:
		case Distance2EdgeXValue:
		case Distance2EdgeSq:
		case Distance2EdgeSqXValue:
			return _Cellular2Edge(x, y);
		default:
			return _Cellular(x, y);
		}
	case FastNoise::NoiseType::CellularHQ:
		switch (m_cellularReturnType)
		{
		case Distance2Edge:
		case Distance2EdgeXValue:
		case Distance2EdgeSq:
		case Distance2EdgeSqXValue:
			return _Cellular2EdgeHQ(x, y);
		default:
			return _CellularHQ(x, y);
		}
	case FastNoise::NoiseType::WhiteNoise:
		return GetWhiteNoise(x, y);
	default:
		return 0.0f;
	}
}

// White Noise
float FastNoise::GetWhiteNoise(float x, float y, float z, float w)
{
	return  GetValCoordNoLUT(m_seed,
		*reinterpret_cast<int*>(&x) ^ (*reinterpret_cast<int*>(&x) >> 16),
		*reinterpret_cast<int*>(&y) ^ (*reinterpret_cast<int*>(&y) >> 16),
		*reinterpret_cast<int*>(&z) ^ (*reinterpret_cast<int*>(&z) >> 16),
		*reinterpret_cast<int*>(&w) ^ (*reinterpret_cast<int*>(&w) >> 16));
}

float FastNoise::GetWhiteNoise(float x, float y, float z)
{
	return  GetValCoordNoLUT(m_seed,
		*reinterpret_cast<int*>(&x) ^ (*reinterpret_cast<int*>(&x) >> 16),
		*reinterpret_cast<int*>(&y) ^ (*reinterpret_cast<int*>(&y) >> 16),
		*reinterpret_cast<int*>(&z) ^ (*reinterpret_cast<int*>(&z) >> 16));
}

float FastNoise::GetWhiteNoise(float x, float y)
{
	return GetValCoordNoLUT(m_seed,
		*reinterpret_cast<int*>(&x) ^ (*reinterpret_cast<int*>(&x) >> 16),
		*reinterpret_cast<int*>(&y) ^ (*reinterpret_cast<int*>(&y) >> 16));
}

float FastNoise::GetWhiteNoiseInt(int x, int y, int z, int w)
{
	return GetValCoordNoLUT(m_seed, x, y, z, w);
}

float FastNoise::GetWhiteNoiseInt(int x, int y, int z)
{
	return GetValCoordNoLUT(m_seed, x, y, z);
}

float FastNoise::GetWhiteNoiseInt(int x, int y)
{
	return GetValCoordNoLUT(m_seed, x, y);
}

float FastNoise::GetValCoordNoLUT(int seed, int x, int y, int z, int w)
{
	int n = X_PRIME * x;
	n ^= Y_PRIME * y;
	n ^= Z_PRIME * z;
	n ^= W_PRIME * w;
	n ^= seed;
	n &= 0x7fffffff;
	n = (n >> 13) ^ n;
	return 1.0f - (((n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff) / 1073741824.0f);
}

float FastNoise::GetValCoordNoLUT(int seed, int x, int y, int z)
{
	int n = X_PRIME * x;
	n ^= Y_PRIME * y;
	n ^= Z_PRIME * z;
	n ^= seed;
	n &= 0x7fffffff;
	n = (n >> 13) ^ n;
	return 1.0f - (((n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff) / 1073741824.0f);
}

float FastNoise::GetValCoordNoLUT(int seed, int x, int y)
{
	int n = X_PRIME * x;
	n ^= Y_PRIME * y;
	n ^= seed;
	n &= 0x7fffffff;
	n = (n >> 13) ^ n;
	return 1.0f - (((n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff) / 1073741824.0f);
}

// Value Noise
float FastNoise::GetValueFractal(float x, float y, float z)
{
	x *= m_frequency;
	y *= m_frequency;
	z *= m_frequency;

	switch (m_fractalType)
	{
	case FastNoise::FBM:
		return _ValueFractalFBM(x, y, z);
	case FastNoise::Billow:
		return _ValueFractalBillow(x, y, z);
	case FastNoise::RigidMulti:
		return _ValueFractalRigidMulti(x, y, z);
	default:
		return 0.0f;
	}
}

float FastNoise::_ValueFractalFBM(float x, float y, float z)
{
	int seed = m_seed;
	float sum = _Value(seed, x, y, z);
	float max = 1.0f;
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;
		z *= m_lacunarity;

		amp *= m_gain;
		max += amp;
		sum += _Value(++seed, x, y, z) * amp;
	}

	return sum / max;
}

float FastNoise::_ValueFractalBillow(float x, float y, float z)
{
	int seed = m_seed;
	float sum = FastAbs(_Value(seed, x, y, z)) * 2.0f - 1.0f;
	float max = 1.0f;
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;
		z *= m_lacunarity;

		amp *= m_gain;
		max += amp;
		sum += (FastAbs(_Value(++seed, x, y, z)) * 2.0f - 1.0f) * amp;
	}

	return sum / max;
}

float FastNoise::_ValueFractalRigidMulti(float x, float y, float z)
{
	int seed = m_seed;
	float sum = 1.0f - FastAbs(_Value(seed, x, y, z));
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;
		z *= m_lacunarity;

		amp *= m_gain;
		sum -= (1.0f - FastAbs(_Value(++seed, x, y, z))) * amp;
	}

	return sum;
}

float FastNoise::GetValue(float x, float y, float z)
{
	return _Value(m_seed, x * m_frequency, y * m_frequency, z * m_frequency);
}

float FastNoise::_Value(int seed, float x, float y, float z)
{
	int x0 = FastFloor(x);
	int y0 = FastFloor(y);
	int z0 = FastFloor(z);
	int x1 = x0 + 1;
	int y1 = y0 + 1;
	int z1 = z0 + 1;

	float xs, ys, zs;
	switch (m_interp)
	{
	case FastNoise::InterpLinear:
		xs = x - (float)x0;
		ys = y - (float)y0;
		zs = z - (float)z0;
		break;
	case FastNoise::InterpHermite:
		xs = InterpHermiteFunc(x - (float)x0);
		ys = InterpHermiteFunc(y - (float)y0);
		zs = InterpHermiteFunc(z - (float)z0);
		break;
	case FastNoise::InterpQuintic:
		xs = InterpQuinticFunc(x - (float)x0);
		ys = InterpQuinticFunc(y - (float)y0);
		zs = InterpQuinticFunc(z - (float)z0);
		break;
	}

	float xf00 = Lerp(GetValCoord(seed, x0, y0, z0), GetValCoord(seed, x1, y0, z0), xs);
	float xf10 = Lerp(GetValCoord(seed, x0, y1, z0), GetValCoord(seed, x1, y1, z0), xs);
	float xf01 = Lerp(GetValCoord(seed, x0, y0, z1), GetValCoord(seed, x1, y0, z1), xs);
	float xf11 = Lerp(GetValCoord(seed, x0, y1, z1), GetValCoord(seed, x1, y1, z1), xs);

	float yf0 = Lerp(xf00, xf10, ys);
	float yf1 = Lerp(xf01, xf11, ys);

	return Lerp(yf0, yf1, zs);
}

float FastNoise::GetValCoord(int seed, int x, int y, int z)
{
	return VAL_LUT[CoordLUTIndex(seed, x, y, z)];
}

float FastNoise::GetValueFractal(float x, float y)
{
	x *= m_frequency;
	y *= m_frequency;

	switch (m_fractalType)
	{
	case FastNoise::FBM:
		return _ValueFractalFBM(x, y);
	case FastNoise::Billow:
		return _ValueFractalBillow(x, y);
	case FastNoise::RigidMulti:
		return _ValueFractalRigidMulti(x, y);
	default:
		return 0.0f;
	}
}

float FastNoise::_ValueFractalFBM(float x, float y)
{
	int seed = m_seed;
	float sum = _Value(seed, x, y);
	float max = 1.0f;
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;

		amp *= m_gain;
		max += amp;
		sum += _Value(++seed, x, y) * amp;
	}

	return sum / max;
}

float FastNoise::_ValueFractalBillow(float x, float y)
{
	int seed = m_seed;
	float sum = FastAbs(_Value(seed, x, y)) * 2.0f - 1.0f;
	float max = 1.0f;
	float amp = 1.0f;

	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;
		amp *= m_gain;
		max += amp;
		sum += (FastAbs(_Value(++seed, x, y)) * 2.0f - 1.0f) * amp;
	}

	return sum / max;
}

float FastNoise::_ValueFractalRigidMulti(float x, float y)
{
	int seed = m_seed;
	float sum = 1.0f - FastAbs(_Value(seed, x, y));
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;

		amp *= m_gain;
		sum -= (1.0f - FastAbs(_Value(++seed, x, y))) * amp;
	}

	return sum;
}

float FastNoise::GetValue(float x, float y)
{
	return _Value(m_seed, x * m_frequency, y * m_frequency);
}

float FastNoise::_Value(int seed, float x, float y)
{
	int x0 = FastFloor(x);
	int y0 = FastFloor(y);
	int x1 = x0 + 1;
	int y1 = y0 + 1;

	float xs, ys;
	switch (m_interp)
	{
	case FastNoise::InterpLinear:
		xs = x - (float)x0;
		ys = y - (float)y0;
		break;
	case FastNoise::InterpHermite:
		xs = InterpHermiteFunc(x - (float)x0);
		ys = InterpHermiteFunc(y - (float)y0);
		break;
	case FastNoise::InterpQuintic:
		xs = InterpQuinticFunc(x - (float)x0);
		ys = InterpQuinticFunc(y - (float)y0);
		break;
	}

	float xf0 = Lerp(GetValCoord(seed, x0, y0), GetValCoord(seed, x1, y0), xs);
	float xf1 = Lerp(GetValCoord(seed, x0, y1), GetValCoord(seed, x1, y1), xs);

	return Lerp(xf0, xf1, ys);
}

float FastNoise::GetValCoord(int seed, int x, int y)
{
	return VAL_LUT[CoordLUTIndex(seed, x, y)];
}

// Gradient Noise
float FastNoise::GetGradientFractal(float x, float y, float z)
{
	x *= m_frequency;
	y *= m_frequency;
	z *= m_frequency;

	switch (m_fractalType)
	{
	case FastNoise::FBM:
		return _GradientFractalFBM(x, y, z);
	case FastNoise::Billow:
		return _GradientFractalBillow(x, y, z);
	case FastNoise::RigidMulti:
		return _GradientFractalRigidMulti(x, y, z);
	default:
		return 0.0f;
	}
}

float FastNoise::_GradientFractalFBM(float x, float y, float z)
{
	int seed = m_seed;
	float sum = _Gradient(seed, x, y, z);
	float max = 1.0f;
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;
		z *= m_lacunarity;

		amp *= m_gain;
		max += amp;
		sum += _Gradient(++seed, x, y, z) * amp;
	}

	return sum / max;
}

float FastNoise::_GradientFractalBillow(float x, float y, float z)
{
	int seed = m_seed;
	float sum = FastAbs(_Gradient(seed, x, y, z)) * 2.0f - 1.0f;
	float max = 1.0f;
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;
		z *= m_lacunarity;

		amp *= m_gain;
		max += amp;
		sum += (FastAbs(_Gradient(++seed, x, y, z)) * 2.0f - 1.0f) * amp;
	}

	return sum / max;
}

float FastNoise::_GradientFractalRigidMulti(float x, float y, float z)
{
	int seed = m_seed;
	float sum = 1.0f - FastAbs(_Gradient(seed, x, y, z));
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;
		z *= m_lacunarity;

		amp *= m_gain;
		sum -= (1.0f - FastAbs(_Gradient(++seed, x, y, z))) * amp;
	}

	return sum;
}

float FastNoise::GetGradient(float x, float y, float z)
{
	return _Gradient(m_seed, x * m_frequency, y * m_frequency, z * m_frequency);
}

float FastNoise::_Gradient(int seed, float x, float y, float z)
{
	int x0 = FastFloor(x);
	int y0 = FastFloor(y);
	int z0 = FastFloor(z);
	int x1 = x0 + 1;
	int y1 = y0 + 1;
	int z1 = z0 + 1;

	float xs, ys, zs;
	switch (m_interp)
	{
	case FastNoise::InterpLinear:
		xs = x - (float)x0;
		ys = y - (float)y0;
		zs = z - (float)z0;
		break;
	case FastNoise::InterpHermite:
		xs = InterpHermiteFunc(x - (float)x0);
		ys = InterpHermiteFunc(y - (float)y0);
		zs = InterpHermiteFunc(z - (float)z0);
		break;
	case FastNoise::InterpQuintic:
		xs = InterpQuinticFunc(x - (float)x0);
		ys = InterpQuinticFunc(y - (float)y0);
		zs = InterpQuinticFunc(z - (float)z0);
		break;
	}

	float xf00 = Lerp(GetGradCoord(seed, x0, y0, z0, x, y, z), GetGradCoord(seed, x1, y0, z0, x, y, z), xs);
	float xf10 = Lerp(GetGradCoord(seed, x0, y1, z0, x, y, z), GetGradCoord(seed, x1, y1, z0, x, y, z), xs);
	float xf01 = Lerp(GetGradCoord(seed, x0, y0, z1, x, y, z), GetGradCoord(seed, x1, y0, z1, x, y, z), xs);
	float xf11 = Lerp(GetGradCoord(seed, x0, y1, z1, x, y, z), GetGradCoord(seed, x1, y1, z1, x, y, z), xs);

	float yf0 = Lerp(xf00, xf10, ys);
	float yf1 = Lerp(xf01, xf11, ys);

	return Lerp(yf0, yf1, zs) * 1.4f;
}

float FastNoise::GetGradCoord(int seed, int xi, int yi, int zi, float x, float y, float z)
{
	float xs = x - (float)xi;
	float ys = y - (float)yi;
	float zs = z - (float)zi;

	int lutPos = CoordLUTIndex(seed, xi, yi, zi);

	return xs*GRAD3D_LUT[lutPos][0] + ys*GRAD3D_LUT[lutPos][1] + zs*GRAD3D_LUT[lutPos][2];
}

float FastNoise::GetGradientFractal(float x, float y)
{
	x *= m_frequency;
	y *= m_frequency;

	switch (m_fractalType)
	{
	case FastNoise::FBM:
		return _GradientFractalFBM(x, y);
	case FastNoise::Billow:
		return _GradientFractalBillow(x, y);
	case FastNoise::RigidMulti:
		return _GradientFractalRigidMulti(x, y);
	default:
		return 0.0f;
	}
}

float FastNoise::_GradientFractalFBM(float x, float y)
{
	int seed = m_seed;
	float sum = _Gradient(seed, x, y);
	float max = 1.0f;
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;

		amp *= m_gain;
		max += amp;
		sum += _Gradient(++seed, x, y) * amp;
	}

	return sum / max;
}

float FastNoise::_GradientFractalBillow(float x, float y)
{
	int seed = m_seed;
	float sum = FastAbs(_Gradient(seed, x, y)) * 2.0f - 1.0f;
	float max = 1.0f;
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;

		amp *= m_gain;
		max += amp;
		sum += (FastAbs(_Gradient(++seed, x, y)) * 2.0f - 1.0f) * amp;
	}

	return sum / max;
}

float FastNoise::_GradientFractalRigidMulti(float x, float y)
{
	int seed = m_seed;
	float sum = 1.0f - FastAbs(_Gradient(seed, x, y));
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;

		amp *= m_gain;
		sum -= (1.0f - FastAbs(_Gradient(++seed, x, y))) * amp;
	}

	return sum;
}

float FastNoise::GetGradient(float x, float y)
{
	return _Gradient(m_seed, x * m_frequency, y * m_frequency);
}

float FastNoise::_Gradient(int seed, float x, float y)
{
	int x0 = FastFloor(x);
	int y0 = FastFloor(y);
	int x1 = x0 + 1;
	int y1 = y0 + 1;

	float xs, ys;
	switch (m_interp)
	{
	case FastNoise::InterpLinear:
		xs = x - (float)x0;
		ys = y - (float)y0;
		break;
	case FastNoise::InterpHermite:
		xs = InterpHermiteFunc(x - (float)x0);
		ys = InterpHermiteFunc(y - (float)y0);
		break;
	case FastNoise::InterpQuintic:
		xs = InterpQuinticFunc(x - (float)x0);
		ys = InterpQuinticFunc(y - (float)y0);
		break;
	}

	float xf0 = Lerp(GetGradCoord(seed, x0, y0, x, y), GetGradCoord(seed, x1, y0, x, y), xs);
	float xf1 = Lerp(GetGradCoord(seed, x0, y1, x, y), GetGradCoord(seed, x1, y1, x, y), xs);

	return Lerp(xf0, xf1, ys) * 1.4f;
}

float FastNoise::GetGradCoord(int seed, int xi, int yi, float x, float y)
{
	float xs = x - (float)xi;
	float ys = y - (float)yi;

	int lutPos = CoordLUTIndex(seed, xi, yi);

	return xs*GRAD2D_LUT[lutPos][0] + ys*GRAD2D_LUT[lutPos][1];
}

// Simplex Noise

float FastNoise::GetSimplexFractal(float x, float y, float z)
{
	x *= m_frequency;
	y *= m_frequency;
	z *= m_frequency;

	switch (m_fractalType)
	{
	case FastNoise::FBM:
		return _SimplexFractalFBM(x, y, z);
	case FastNoise::Billow:
		return _SimplexFractalBillow(x, y, z);
	case FastNoise::RigidMulti:
		return _SimplexFractalRigidMulti(x, y, z);
	default:
		return 0.0f;
	}
}

float FastNoise::_SimplexFractalFBM(float x, float y, float z)
{
	int seed = m_seed;
	float sum = _Simplex(seed, x, y, z);
	float max = 1.0f;
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;
		z *= m_lacunarity;

		amp *= m_gain;
		max += amp;
		sum += _Simplex(++seed, x, y, z) * amp;
	}

	return sum / max;
}

float FastNoise::_SimplexFractalBillow(float x, float y, float z)
{
	int seed = m_seed;
	float sum = FastAbs(_Simplex(seed, x, y, z)) * 2.0f - 1.0f;
	float max = 1.0f;
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;
		z *= m_lacunarity;

		amp *= m_gain;
		max += amp;
		sum += (FastAbs(_Simplex(++seed, x, y, z)) * 2.0f - 1.0f) * amp;
	}

	return sum / max;
}

float FastNoise::_SimplexFractalRigidMulti(float x, float y, float z)
{
	int seed = m_seed;
	float sum = 1.0f - FastAbs(_Simplex(seed, x, y, z));
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;
		z *= m_lacunarity;

		amp *= m_gain;
		sum -= (1.0f - FastAbs(_Simplex(++seed, x, y, z))) * amp;
	}

	return sum;
}

float FastNoise::GetSimplex(float x, float y, float z)
{
	return _Simplex(m_seed, x * m_frequency, y * m_frequency, z * m_frequency);
}

static inline float Dot(const float *g, float x, float y, float z)
{
	return g[0] * x + g[1] * y + g[2] * z;
}

static const float F3 = 1.0f / 3.0f;
static const float G3 = 1.0f / 6.0f;

float FastNoise::_Simplex(int seed, float x, float y, float z)
{
	float t = (x + y + z) * F3;
	int i = FastFloor(x + t);
	int j = FastFloor(y + t);
	int k = FastFloor(z + t);

	t = (i + j + k) * G3;
	float X0 = i - t;
	float Y0 = j - t;
	float Z0 = k - t;

	float x0 = x - X0;
	float y0 = y - Y0;
	float z0 = z - Z0;

	int i1, j1, k1;
	int i2, j2, k2;

	if (x0 >= y0)
	{
		if (y0 >= z0)
		{
			i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
		}
		else if (x0 >= z0)
		{
			i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;
		}
		else
		{
			i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;
		}
	}
	else
	{
		if (y0 < z0)
		{
			i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;
		}
		else if (x0 < z0)
		{
			i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;
		}
		else
		{
			i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
		}
	}

	float x1 = x0 - i1 + G3;
	float y1 = y0 - j1 + G3;
	float z1 = z0 - k1 + G3;
	float x2 = x0 - i2 + 2.0f*G3;
	float y2 = y0 - j2 + 2.0f*G3;
	float z2 = z0 - k2 + 2.0f*G3;
	float x3 = x0 - 1.0f + 3.0f*G3;
	float y3 = y0 - 1.0f + 3.0f*G3;
	float z3 = z0 - 1.0f + 3.0f*G3;

	float n0, n1, n2, n3;

	t = 0.6f - x0*x0 - y0*y0 - z0*z0;
	if (t < 0.0f) n0 = 0.0f;
	else
	{
		t *= t;
		n0 = t*t*Dot(&GRAD3D_LUT[CoordLUTIndex(seed, i, j, k)][0], x0, y0, z0);
	}

	t = 0.6f - x1*x1 - y1*y1 - z1*z1;
	if (t < 0.0f) n1 = 0.0f;
	else
	{
		t *= t;
		n1 = t*t*Dot(&GRAD3D_LUT[CoordLUTIndex(seed, i + i1, j + j1, k + k1)][0], x1, y1, z1);
	}

	t = 0.6f - x2*x2 - y2*y2 - z2*z2;
	if (t < 0.0f) n2 = 0.0f;
	else
	{
		t *= t;
		n2 = t*t*Dot(&GRAD3D_LUT[CoordLUTIndex(seed, i + i2, j + j2, k + k2)][0], x2, y2, z2);
	}

	t = 0.6f - x3*x3 - y3*y3 - z3*z3;
	if (t < 0.0f) n3 = 0.0f;
	else
	{
		t *= t;
		n3 = t*t*Dot(&GRAD3D_LUT[CoordLUTIndex(seed, i + 1, j + 1, k + 1)][0], x3, y3, z3);
	}

	return 40.0f * (n0 + n1 + n2 + n3);
}

float FastNoise::GetSimplexFractal(float x, float y)
{
	x *= m_frequency;
	y *= m_frequency;

	switch (m_fractalType)
	{
	case FastNoise::FBM:
		return _SimplexFractalFBM(x, y);
	case FastNoise::Billow:
		return _SimplexFractalBillow(x, y);
	case FastNoise::RigidMulti:
		return _SimplexFractalRigidMulti(x, y);
	default:
		return 0.0f;
	}
}

float FastNoise::_SimplexFractalFBM(float x, float y)
{
	int seed = m_seed;
	float sum = _Simplex(seed, x, y);
	float max = 1.0f;
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;

		amp *= m_gain;
		max += amp;
		sum += _Simplex(++seed, x, y) * amp;
	}

	return sum / max;
}

float FastNoise::_SimplexFractalBillow(float x, float y)
{
	int seed = m_seed;
	float sum = FastAbs(_Simplex(seed, x, y)) * 2.0f - 1.0f;
	float max = 1.0f;
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;

		amp *= m_gain;
		max += amp;
		sum += (FastAbs(_Simplex(++seed, x, y)) * 2.0f - 1.0f) * amp;
	}

	return sum / max;
}

float FastNoise::_SimplexFractalRigidMulti(float x, float y)
{
	int seed = m_seed;
	float sum = 1.0f - FastAbs(_Simplex(seed, x, y));
	float amp = 1.0f;
	unsigned int i = 0;

	while (++i < m_octaves)
	{
		x *= m_lacunarity;
		y *= m_lacunarity;

		amp *= m_gain;
		sum -= (1.0f - FastAbs(_Simplex(++seed, x, y))) * amp;
	}

	return sum;
}

float FastNoise::GetSimplex(float x, float y)
{
	return _Simplex(m_seed, x * m_frequency, y * m_frequency);
}

static inline float Dot(const float *g, float x, float y)
{
	return g[0] * x + g[1] * y;
}

static const float F2 = 1.f / 2.f;
static const float G2 = 1.f / 4.f;

float FastNoise::_Simplex(int seed, float x, float y)
{
	float t = (x + y) * F2;
	int i = FastFloor(x + t);
	int j = FastFloor(y + t);

	t = (i + j) * G2;
	float X0 = i - t;
	float Y0 = j - t;

	float x0 = x - X0;
	float y0 = y - Y0;

	int i1, j1;
	if (x0 > y0)
	{
		i1 = 1; j1 = 0;
	}
	else
	{
		i1 = 0; j1 = 1;
	}

	float x1 = x0 - (float)i1 + G2;
	float y1 = y0 - (float)j1 + G2;
	float x2 = x0 - 1.0f + 2.0f*G2;
	float y2 = y0 - 1.0f + 2.0f*G2;

	float n0, n1, n2;

	t = 0.6f - x0*x0 - y0*y0;
	if (t < 0) n0 = 0;
	else
	{
		t *= t;
		n0 = t * t * Dot(&GRAD2D_LUT[CoordLUTIndex(seed, i, j)][0], x0, y0);
	}

	t = 0.6f - x1*x1 - y1*y1;
	if (t < 0) n1 = 0;
	else
	{
		t *= t;
		n1 = t*t*Dot(&GRAD2D_LUT[CoordLUTIndex(seed, i + i1, j + j1)][0], x1, y1);
	}

	t = 0.6f - x2*x2 - y2*y2;
	if (t < 0) n2 = 0;
	else
	{
		t *= t;
		n2 = t*t*Dot(&GRAD2D_LUT[CoordLUTIndex(seed, i + 1, j + 1)][0], x2, y2);
	}

	return  27.7f * (n0 + n1 + n2);// +0.001054489f;
}

float FastNoise::GetSimplex(float x, float y, float z, float w)
{
	return _Simplex(x * m_frequency, y * m_frequency, z * m_frequency, w * m_frequency);
}

static inline float Dot(const float *g, float x, float y, float z, float w)
{
	return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
}

static const int SIMPLEX4D[64][4] =
{
	{ 0, 1, 2, 3 }, { 0, 1, 3, 2 }, { 0, 0, 0, 0 }, { 0, 2, 3, 1 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 1, 2, 3, 0 },
	{ 0, 2, 1, 3 }, { 0, 0, 0, 0 }, { 0, 3, 1, 2 }, { 0, 3, 2, 1 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 1, 3, 2, 0 },
	{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 },
	{ 1, 2, 0, 3 }, { 0, 0, 0, 0 }, { 1, 3, 0, 2 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 2, 3, 0, 1 }, { 2, 3, 1, 0 },
	{ 1, 0, 2, 3 }, { 1, 0, 3, 2 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 2, 0, 3, 1 }, { 0, 0, 0, 0 }, { 2, 1, 3, 0 },
	{ 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 },
	{ 2, 0, 1, 3 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 3, 0, 1, 2 }, { 3, 0, 2, 1 }, { 0, 0, 0, 0 }, { 3, 1, 2, 0 },
	{ 2, 1, 0, 3 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 3, 1, 0, 2 }, { 0, 0, 0, 0 }, { 3, 2, 0, 1 }, { 3, 2, 1, 0 }
};

static const float F4 = (sqrtf(5.0f) - 1.0f) / 4.0f;
static const float G4 = (5.0f - sqrtf(5.0f)) / 20.0f;

float FastNoise::_Simplex(float x, float y, float z, float w)
{
	float n0, n1, n2, n3, n4;
	float t = (x + y + z + w) * F4; 
	int i = FastFloor(x + t);
	int j = FastFloor(y + t);
	int k = FastFloor(z + t);
	int l = FastFloor(w + t);
	t = (i + j + k + l) * G4; 
	float X0 = i - t; 
	float Y0 = j - t;
	float Z0 = k - t;
	float W0 = l - t;
	float x0 = x - X0; 
	float y0 = y - Y0;
	float z0 = z - Z0;
	float w0 = w - W0;

	int c = (x0 > y0) ? 32 : 0;
	c += (x0 > z0) ? 16 : 0;
	c += (y0 > z0) ? 8 : 0;
	c += (x0 > w0) ? 4 : 0;
	c += (y0 > w0) ? 2 : 0;
	c += (z0 > w0) ? 1 : 0;
	int i1, j1, k1, l1; 
	int i2, j2, k2, l2; 
	int i3, j3, k3, l3; 
	
	i1 = SIMPLEX4D[c][0] >= 3 ? 1 : 0;
	j1 = SIMPLEX4D[c][1] >= 3 ? 1 : 0;
	k1 = SIMPLEX4D[c][2] >= 3 ? 1 : 0;
	l1 = SIMPLEX4D[c][3] >= 3 ? 1 : 0;
	i2 = SIMPLEX4D[c][0] >= 2 ? 1 : 0;
	j2 = SIMPLEX4D[c][1] >= 2 ? 1 : 0;
	k2 = SIMPLEX4D[c][2] >= 2 ? 1 : 0;
	l2 = SIMPLEX4D[c][3] >= 2 ? 1 : 0;
	i3 = SIMPLEX4D[c][0] >= 1 ? 1 : 0;
	j3 = SIMPLEX4D[c][1] >= 1 ? 1 : 0;
	k3 = SIMPLEX4D[c][2] >= 1 ? 1 : 0;
	l3 = SIMPLEX4D[c][3] >= 1 ? 1 : 0;
	
	float x1 = x0 - i1 + G4; 
	float y1 = y0 - j1 + G4;
	float z1 = z0 - k1 + G4;
	float w1 = w0 - l1 + G4;
	float x2 = x0 - i2 + 2.0f*G4; 
	float y2 = y0 - j2 + 2.0f*G4;
	float z2 = z0 - k2 + 2.0f*G4;
	float w2 = w0 - l2 + 2.0f*G4;
	float x3 = x0 - i3 + 3.0f*G4; 
	float y3 = y0 - j3 + 3.0f*G4;
	float z3 = z0 - k3 + 3.0f*G4;
	float w3 = w0 - l3 + 3.0f*G4;
	float x4 = x0 - 1.0f + 4.0f*G4; 
	float y4 = y0 - 1.0f + 4.0f*G4;
	float z4 = z0 - 1.0f + 4.0f*G4;
	float w4 = w0 - 1.0f + 4.0f*G4;

	t = 0.6f - x0*x0 - y0*y0 - z0*z0 - w0*w0;
	if (t<0.f) n0 = 0.0f;
	else {
		t *= t;
		n0 = t * t * Dot(&GRAD4D_LUT[CoordLUTIndex(i,j,k,l)][0], x0, y0, z0, w0);
	}
	t = 0.6f - x1*x1 - y1*y1 - z1*z1 - w1*w1;
	if (t<0.f) n1 = 0.0f;
	else {
		t *= t;
		n1 = t * t * Dot(&GRAD4D_LUT[CoordLUTIndex(i + i1, j+j1, k+k1, l+l1)][0], x1, y1, z1, w1);
	}
	t = 0.6f - x2*x2 - y2*y2 - z2*z2 - w2*w2;
	if (t<0.f) n2 = 0.0f;
	else {
		t *= t;
		n2 = t * t * Dot(&GRAD4D_LUT[CoordLUTIndex(i + i2, j + j2, k + k2, l + l2)][0], x2, y2, z2, w2);
	}
	t = 0.6f - x3*x3 - y3*y3 - z3*z3 - w3*w3;
	if (t<0.f) n3 = 0.0f;
	else {
		t *= t;
		n3 = t * t * Dot(&GRAD4D_LUT[CoordLUTIndex(i + i3, j + j3, k + k3, l + l3)][0], x3, y3, z3, w3);
	}
	t = 0.6f - x4*x4 - y4*y4 - z4*z4 - w4*w4;
	if (t<0.f) n4 = 0.0f;
	else {
		t *= t;
		n4 = t * t * Dot(&GRAD4D_LUT[CoordLUTIndex(i + 1, j + 1, k + 1, l + 1)][0], x4, y4, z4, w4);
	}

	return 44.5f * (n0 + n1 + n2 + n3 + n4);
}

// Cellular Noise
float FastNoise::GetCellular(float x, float y, float z)
{
	x *= m_frequency;
	y *= m_frequency;
	z *= m_frequency;

	switch (m_cellularReturnType)
	{
	case Distance2Edge:
	case Distance2EdgeXValue:
	case Distance2EdgeSq:
	case Distance2EdgeSqXValue:
		return _Cellular2Edge(x, y, z);
	default:
		return _Cellular(x, y, z);
	}
}

float FastNoise::GetCellular(float x, float y, float z, float w)
{
    x *= m_frequency;
    y *= m_frequency;
    z *= m_frequency;
    w *= m_frequency;

    switch(m_cellularReturnType)
    {
    case Distance2Edge:
    case Distance2EdgeXValue:
    case Distance2EdgeSq:
    case Distance2EdgeSqXValue:
    {
        int xr = FastRound(x);
        int yr = FastRound(y);
        int zr = FastRound(z);
        int wr = FastRound(w);

        float distance = 999999.f;
        float distance2 = 999999.f;
        float newDistance;
        float vec[4];
        int lutPos;
        int xc = 0, yc = 0, zc = 0, wc = 0;

        switch (m_cellularDistanceFunction)
        {
        case FastNoise::Euclidean:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    for (int zi = zr - 1; zi <= zr + 1; zi++)
                    {
                        for (int wi = wr - 1; wi <= wr + 1; wi++)
                        {
                            lutPos = CoordLUTIndex(m_seed, xi, yi, zi, wi);

                            vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
                            vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
                            vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];
                            vec[3] = wi - w + VAL_LUT[lutPos];
                            //vec[3] = wi - w + CELLULAR2D_LUT[lutPos][0];

                            newDistance = vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2] + vec[3]*vec[3];

                            if (newDistance < distance)
                            {
                                distance2 = distance;

                                distance = newDistance;
                                xc = xi;
                                yc = yi;
                                zc = zi;
                                wc = zi;
                            }
                            else if (newDistance < distance2)
                            {
                                distance2 = newDistance;
                            }
                        }
                    }
                }
            }
            break;
        case FastNoise::Manhattan:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    for (int zi = zr - 1; zi <= zr + 1; zi++)
                    {
                        for (int wi = wr - 1; wi <= wr + 1; wi++)
                        {
                            lutPos = CoordLUTIndex(m_seed, xi, yi, zi, wi);

                            vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
                            vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
                            vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];
                            vec[3] = wi - w + VAL_LUT[lutPos];

                            newDistance = FastAbs(vec[0]) + FastAbs(vec[1]) + FastAbs(vec[2]) + FastAbs(vec[3]);

                            if (newDistance < distance)
                            {
                                distance2 = distance;

                                distance = newDistance;
                                xc = xi;
                                yc = yi;
                                zc = zi;
                                wc = wi;
                            }
                            else if (newDistance < distance2)
                            {
                                distance2 = newDistance;
                            }
                        }
                    }
                }
            }
            break;
        case FastNoise::Natural:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    for (int zi = zr - 1; zi <= zr + 1; zi++)
                    {
                        for (int wi = wr - 1; wi <= wr + 1; wi++)
                        {
                            lutPos = CoordLUTIndex(m_seed, xi, yi, zi, wi);

                            vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
                            vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
                            vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];
                            vec[3] = wi - w + VAL_LUT[lutPos];


                            newDistance = (FastAbs(vec[0]) + FastAbs(vec[1]) + FastAbs(vec[2]) + FastAbs(vec[3])) * (vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2] + vec[3]*vec[3]);

                            if (newDistance < distance)
                            {
                                distance2 = distance;

                                distance = newDistance;
                                xc = xi;
                                yc = yi;
                                zc = zi;
                                wc = wi;
                            }
                            else if (newDistance < distance2)
                            {
                                distance2 = newDistance;
                            }
                        }
                    }
                }
            }
            break;
        case FastNoise::Rect:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    for (int zi = zr - 1; zi <= zr + 1; zi++)
                    {
                        for (int wi = wr - 1; wi <= wr + 1; wi++)
                        {
                            lutPos = CoordLUTIndex(m_seed, xi, yi, zi, wi);

                            vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
                            vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
                            vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];
                            vec[3] = wi - w + VAL_LUT[lutPos];

                            newDistance = fmaxf(FastAbs(vec[0]),fmaxf(FastAbs(vec[1]), fmaxf(FastAbs(vec[2]), FastAbs(vec[3]))));

                            if (newDistance < distance)
                            {
                                distance2 = distance;

                                distance = newDistance;
                                xc = xi;
                                yc = yi;
                                zc = zi;
                                wc = wi;
                            }
                            else if (newDistance < distance2)
                            {
                                distance2 = newDistance * newDistance;
                            }
                        }
                    }
                }
            }
            break;
        default:
            break;
        }

        switch (m_cellularReturnType)
        {
        case FastNoise::Distance2Edge:
            return sqrtf(distance2) - sqrtf(distance);
        case FastNoise::Distance2EdgeXValue:
            return (sqrtf(distance2) - sqrtf(distance)) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc)];

        case FastNoise::Distance2EdgeSq:
            return distance2 - distance;
        case FastNoise::Distance2EdgeSqXValue:
            return (distance2 - distance) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc)];
        default:
            return 0.0f;
        }
    }
    default:
    {
        int xr = FastRound(x);
        int yr = FastRound(y);
        int zr = FastRound(z);
        int wr = FastRound(w);

        float distance = 999999.f;
        float newDistance;
        float vec[4];
        int lutPos;
        int xc, yc, zc, wc;

        switch (m_cellularDistanceFunction)
        {
        case FastNoise::Euclidean:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    for (int zi = zr - 1; zi <= zr + 1; zi++)
                    {
                        for (int wi = wr - 1; wi <= wr + 1; wi++)
                        {
                            lutPos = CoordLUTIndex(m_seed, xi, yi, zi, wi);

                            vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
                            vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
                            vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];
                            vec[3] = wi - w + VAL_LUT[lutPos];

                            newDistance = vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2] + vec[3] * vec[3];

                            if (newDistance < distance)
                            {
                                distance = newDistance;
                                xc = xi;
                                yc = yi;
                                zc = zi;
                                wc = wi;
                            }
                        }
                    }
                }
            }
            break;
        case FastNoise::Manhattan:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    for (int zi = zr - 1; zi <= zr + 1; zi++)
                    {
                        for (int wi = wr - 1; wi <= wr + 1; wi++)
                        {
                            lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

                            vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
                            vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
                            vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];
                            vec[3] = wi - w + VAL_LUT[lutPos];

                            newDistance = FastAbs(vec[0]) + FastAbs(vec[1]) + FastAbs(vec[2]) + FastAbs(vec[3]);

                            if (newDistance < distance)
                            {
                                distance = newDistance;
                                xc = xi;
                                yc = yi;
                                zc = zi;
                                wc = wi;
                            }
                        }
                    }
                }
            }
            break;
        case FastNoise::Natural:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    for (int zi = zr - 1; zi <= zr + 1; zi++)
                    {
                        for (int wi = wr - 1; wi <= wr + 1; wi++)
                        {
                            lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

                            vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
                            vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
                            vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];
                            vec[3] = wi - w + VAL_LUT[lutPos];

                            newDistance = (FastAbs(vec[0]) + FastAbs(vec[1]) + FastAbs(vec[2]) + FastAbs(vec[3])) * (vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2] + vec[3] * vec[3]);

                            if (newDistance < distance)
                            {
                                distance = newDistance;
                                xc = xi;
                                yc = yi;
                                zc = zi;
                                wc = wi;
                            }
                        }
                    }
                }
            }
            break;
        case FastNoise::Rect:
            for (int xi = xr - 1; xi <= xr + 1; xi++)
            {
                for (int yi = yr - 1; yi <= yr + 1; yi++)
                {
                    for (int zi = zr - 1; zi <= zr + 1; zi++)
                    {
                        for (int wi = wr - 1; wi <= wr + 1; wi++)
                        {
                            lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

                            vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
                            vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
                            vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];
                            vec[3] = wi - w + VAL_LUT[lutPos];

                            newDistance = fmaxf(fabsf(vec[0]), fmaxf(fabsf(vec[1]), fmaxf(fabsf(vec[2]), fabsf(vec[3]))));

                            if (newDistance < distance)
                            {
                                distance = newDistance * newDistance;
                                xc = xi;
                                yc = yi;
                                zc = zi;
                                wc = wi;
                            }
                        }
                    }
                }
            }
            break;
        default:
            xc = 0;
            yc = 0;
            zc = 0;
            wc = 0;
            break;
        }

        switch (m_cellularReturnType)
        {
        case FastNoise::CellValue:
            return VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc, wc)];

        case FastNoise::NoiseLookup:
            if (!m_cellularNoiseLookup)
                return 0;

            lutPos = CoordLUTIndex(m_seed, xc, yc, zc);
            return m_cellularNoiseLookup->GetNoise(xc + CELLULAR3D_LUT[lutPos][0], yc + CELLULAR3D_LUT[lutPos][1], zc + CELLULAR3D_LUT[lutPos][2]);

        case FastNoise::Distance2Center:
            return sqrtf(distance);
        case FastNoise::Distance2CenterXValue:
            return (1.0f - sqrtf(distance)) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc, wc)];

        case FastNoise::Distance2CenterSq:
            return distance;
        case FastNoise::Distance2CenterSqXValue:
            return (1.0f - distance) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc, wc)];
        default:
            return 0.0f;
        }
    }
    }
}

float FastNoise::_Cellular(float x, float y, float z)
{
	int xr = FastRound(x);
	int yr = FastRound(y);
	int zr = FastRound(z);

	float distance = 999999.f;
	float newDistance;
	float vec[3];
	int lutPos;
	int xc, yc, zc;

	switch (m_cellularDistanceFunction)
	{
	case FastNoise::Euclidean:
	for (int xi = xr - 1; xi <= xr + 1; xi++)
	{
		for (int yi = yr - 1; yi <= yr + 1; yi++)
		{
			for (int zi = zr - 1; zi <= zr + 1; zi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

				vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
				vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];

				newDistance = vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2];

				if (newDistance < distance)
				{
					distance = newDistance;
					xc = xi;
					yc = yi;
					zc = zi;
				}
			}
		}
	}
		break;
	case FastNoise::Manhattan:
		for (int xi = xr - 1; xi <= xr + 1; xi++)
		{
			for (int yi = yr - 1; yi <= yr + 1; yi++)
			{
				for (int zi = zr - 1; zi <= zr + 1; zi++)
				{
					lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

					vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
					vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];

					newDistance = FastAbs(vec[0]) + FastAbs(vec[1]) + FastAbs(vec[2]);

					if (newDistance < distance)
					{
						distance = newDistance;
						xc = xi;
						yc = yi;
						zc = zi;
					}
				}
			}
		}
		break;
	case FastNoise::Natural:
		for (int xi = xr - 1; xi <= xr + 1; xi++)
		{
			for (int yi = yr - 1; yi <= yr + 1; yi++)
			{
				for (int zi = zr - 1; zi <= zr + 1; zi++)
				{
					lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

					vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
					vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];

					newDistance = (FastAbs(vec[0]) + FastAbs(vec[1]) + FastAbs(vec[2])) * (vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);

					if (newDistance < distance)
					{
						distance = newDistance;
						xc = xi;
						yc = yi;
						zc = zi;
					}
				}
			}
		}
		break;
    case FastNoise::Rect:
        for (int xi = xr - 1; xi <= xr + 1; xi++)
        {
            for (int yi = yr - 1; yi <= yr + 1; yi++)
            {
                for (int zi = zr - 1; zi <= zr + 1; zi++)
                {
                    lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

                    vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
                    vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
                    vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];

                    newDistance = fmaxf(vec[0], fmaxf(vec[1], vec[2]));

                    if (newDistance < distance)
                    {
                        distance = newDistance;
                        xc = xi;
                        yc = yi;
                        zc = zi;
                    }
                }
            }
        }
        break;
	default:
        xc = 0;
        yc = 0;
        zc = 0;
		break;
	}

	switch (m_cellularReturnType)
	{
	case FastNoise::CellValue:
		return VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc)];

	case FastNoise::NoiseLookup:		
		if (!m_cellularNoiseLookup)
			return 0;

		lutPos = CoordLUTIndex(m_seed, xc, yc, zc);
		return m_cellularNoiseLookup->GetNoise(xc + CELLULAR3D_LUT[lutPos][0], yc + CELLULAR3D_LUT[lutPos][1], zc + CELLULAR3D_LUT[lutPos][2]);
		
	case FastNoise::Distance2Center:
		return sqrtf(distance);
	case FastNoise::Distance2CenterXValue:
		return (1.0f - sqrtf(distance)) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc)];

	case FastNoise::Distance2CenterSq:
		return distance;
	case FastNoise::Distance2CenterSqXValue:
		return (1.0f - distance) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc)];
	default:
		return 0.0f;
	}
}

float FastNoise::_Cellular2Edge(float x, float y, float z)
{
	int xr = FastRound(x);
	int yr = FastRound(y);
	int zr = FastRound(z);

	float distance = 999999.f;
	float distance2 = 999999.f;
	float newDistance;
	float vec[3];
	int lutPos;
	int xc = 0, yc = 0, zc = 0;

	switch (m_cellularDistanceFunction)
	{
	case FastNoise::Euclidean:
		for (int xi = xr - 1; xi <= xr + 1; xi++)
		{
			for (int yi = yr - 1; yi <= yr + 1; yi++)
			{
				for (int zi = zr - 1; zi <= zr + 1; zi++)
				{
					lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

					vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
					vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];

					newDistance = vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2];

					if (newDistance < distance)
					{
						distance2 = distance;

						distance = newDistance;
						xc = xi;
						yc = yi;
						zc = zi;						
					}
					else if (newDistance < distance2)
					{
						distance2 = newDistance;
					}
				}
			}
		}
		break;
	case FastNoise::Manhattan:
		for (int xi = xr - 1; xi <= xr + 1; xi++)
		{
			for (int yi = yr - 1; yi <= yr + 1; yi++)
			{
				for (int zi = zr - 1; zi <= zr + 1; zi++)
				{
					lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

					vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
					vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];

					newDistance = FastAbs(vec[0]) + FastAbs(vec[1]) + FastAbs(vec[2]);

					if (newDistance < distance)
					{
						distance2 = distance;

						distance = newDistance;
						xc = xi;
						yc = yi;
						zc = zi;
					}
					else if (newDistance < distance2)
					{
						distance2 = newDistance;
					}
				}
			}
		}
		break;
	case FastNoise::Natural:
		for (int xi = xr - 1; xi <= xr + 1; xi++)
		{
			for (int yi = yr - 1; yi <= yr + 1; yi++)
			{
				for (int zi = zr - 1; zi <= zr + 1; zi++)
				{
					lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

					vec[0] = xi - x + CELLULAR3D_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR3D_LUT[lutPos][1];
					vec[2] = zi - z + CELLULAR3D_LUT[lutPos][2];

					newDistance = (FastAbs(vec[0]) + FastAbs(vec[1]) + FastAbs(vec[2])) * (vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);

					if (newDistance < distance)
					{
						distance2 = distance;

						distance = newDistance;
						xc = xi;
						yc = yi;
						zc = zi;
					}
					else if (newDistance < distance2)
					{
						distance2 = newDistance;
					}
				}
			}
		}
		break;
	default:
		break;
	}

	switch (m_cellularReturnType)
	{
	case FastNoise::Distance2Edge:
		return sqrtf(distance2) - sqrtf(distance);
	case FastNoise::Distance2EdgeXValue:
		return (sqrtf(distance2) - sqrtf(distance)) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc)];

	case FastNoise::Distance2EdgeSq:
		return distance2 - distance;
	case FastNoise::Distance2EdgeSqXValue:
		return (distance2 - distance) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc)];
	default:
		return 0.0f;
	}
}

float FastNoise::GetCellularHQ(float x, float y, float z)
{
	x *= m_frequency;
	y *= m_frequency;
	z *= m_frequency;

	switch (m_cellularReturnType)
	{
	case Distance2Edge:
	case Distance2EdgeXValue:
	case Distance2EdgeSq:
	case Distance2EdgeSqXValue:
		return _Cellular2EdgeHQ(x, y, z);
	default:
		return _CellularHQ(x, y, z);
	}
}

float FastNoise::_CellularHQ(float x, float y, float z)
{
	int xr = FastRound(x);
	int yr = FastRound(y);
	int zr = FastRound(z);

	float distance = 999999.f;
	float newDistance;
	float vec[3];
	int lutPos;
	int xc, yc, zc;

	switch (m_cellularDistanceFunction)
	{
	case FastNoise::Euclidean:
		for (int xi = xr - 2; xi <= xr + 2; xi++)
		{
			for (int yi = yr - 2; yi <= yr + 2; yi++)
			{
				for (int zi = zr - 2; zi <= zr + 2; zi++)
				{
					lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

					vec[0] = xi - x + CELLULAR3D_HQ_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR3D_HQ_LUT[lutPos][1];
					vec[2] = zi - z + CELLULAR3D_HQ_LUT[lutPos][2];

					newDistance = vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2];

					if (newDistance < distance)
					{
						distance = newDistance;
						xc = xi;
						yc = yi;
						zc = zi;
					}
				}
			}
		}
		break;
	case FastNoise::Manhattan:
		for (int xi = xr - 2; xi <= xr + 2; xi++)
		{
			for (int yi = yr - 2; yi <= yr + 2; yi++)
			{
				for (int zi = zr - 2; zi <= zr + 2; zi++)
				{
					lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

					vec[0] = xi - x + CELLULAR3D_HQ_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR3D_HQ_LUT[lutPos][1];
					vec[2] = zi - z + CELLULAR3D_HQ_LUT[lutPos][2];

					newDistance = FastAbs(vec[0]) + FastAbs(vec[1]) + FastAbs(vec[2]);

					if (newDistance < distance)
					{
						distance = newDistance;
						xc = xi;
						yc = yi;
						zc = zi;
					}
				}
			}
		}
		break;
	case FastNoise::Natural:
		for (int xi = xr - 2; xi <= xr + 2; xi++)
		{
			for (int yi = yr - 2; yi <= yr + 2; yi++)
			{
				for (int zi = zr - 2; zi <= zr + 2; zi++)
				{
					lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

					vec[0] = xi - x + CELLULAR3D_HQ_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR3D_HQ_LUT[lutPos][1];
					vec[2] = zi - z + CELLULAR3D_HQ_LUT[lutPos][2];

					newDistance = (FastAbs(vec[0]) + FastAbs(vec[1]) + FastAbs(vec[2])) * (vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);

					if (newDistance < distance)
					{
						distance = newDistance;
						xc = xi;
						yc = yi;
						zc = zi;
					}
				}
			}
		}
		break;
	default:
		break;
	}

	switch (m_cellularReturnType)
	{
	case FastNoise::CellValue:
		return VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc)];

	case FastNoise::NoiseLookup:
		if (!m_cellularNoiseLookup)
			return 0;

		lutPos = CoordLUTIndex(m_seed, xc, yc, zc);
		return m_cellularNoiseLookup->GetNoise(xc + CELLULAR3D_HQ_LUT[lutPos][0], yc + CELLULAR3D_HQ_LUT[lutPos][1], zc + CELLULAR3D_HQ_LUT[lutPos][2]);

	case FastNoise::Distance2Center:
		return sqrtf(distance);
	case FastNoise::Distance2CenterXValue:
		return (1.0f - sqrtf(distance)) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc)];

	case FastNoise::Distance2CenterSq:
		return distance;
	case FastNoise::Distance2CenterSqXValue:
		return (1.0f - distance) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc)];
	default:
		return 0.0f;
	}
}

float FastNoise::_Cellular2EdgeHQ(float x, float y, float z)
{
	int xr = FastRound(x);
	int yr = FastRound(y);
	int zr = FastRound(z);

	float distance = 999999.f;
	float distance2 = 999999.f;
	float newDistance;
	float vec[3];
	int lutPos;
	int xc = 0, yc = 0, zc = 0;

	switch (m_cellularDistanceFunction)
	{
	case FastNoise::Euclidean:
		for (int xi = xr - 2; xi <= xr + 2; xi++)
		{
			for (int yi = yr - 2; yi <= yr + 2; yi++)
			{
				for (int zi = zr - 2; zi <= zr + 2; zi++)
				{
					lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

					vec[0] = xi - x + CELLULAR3D_HQ_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR3D_HQ_LUT[lutPos][1];
					vec[2] = zi - z + CELLULAR3D_HQ_LUT[lutPos][2];

					newDistance = vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2];

					if (newDistance < distance)
					{
						distance2 = distance;

						distance = newDistance;
						xc = xi;
						yc = yi;
						zc = zi;
					}
					else if (newDistance < distance2)
					{
						distance2 = newDistance;
					}
				}
			}
		}
		break;
	case FastNoise::Manhattan:
		for (int xi = xr - 2; xi <= xr + 2; xi++)
		{
			for (int yi = yr - 2; yi <= yr + 2; yi++)
			{
				for (int zi = zr - 2; zi <= zr + 2; zi++)
				{
					lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

					vec[0] = xi - x + CELLULAR3D_HQ_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR3D_HQ_LUT[lutPos][1];
					vec[2] = zi - z + CELLULAR3D_HQ_LUT[lutPos][2];

					newDistance = FastAbs(vec[0]) + FastAbs(vec[1]) + FastAbs(vec[2]);

					if (newDistance < distance)
					{
						distance2 = distance;

						distance = newDistance;
						xc = xi;
						yc = yi;
						zc = zi;
					}
					else if (newDistance < distance2)
					{
						distance2 = newDistance;
					}
				}
			}
		}
		break;
	case FastNoise::Natural:
		for (int xi = xr - 2; xi <= xr + 2; xi++)
		{
			for (int yi = yr - 2; yi <= yr + 2; yi++)
			{
				for (int zi = zr - 2; zi <= zr + 2; zi++)
				{
					lutPos = CoordLUTIndex(m_seed, xi, yi, zi);

					vec[0] = xi - x + CELLULAR3D_HQ_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR3D_HQ_LUT[lutPos][1];
					vec[2] = zi - z + CELLULAR3D_HQ_LUT[lutPos][2];

					newDistance = (FastAbs(vec[0]) + FastAbs(vec[1]) + FastAbs(vec[2])) * (vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);

					if (newDistance < distance)
					{
						distance2 = distance;

						distance = newDistance;
						xc = xi;
						yc = yi;
						zc = zi;
					}
					else if (newDistance < distance2)
					{
						distance2 = newDistance;
					}
				}
			}
		}
		break;
	default:
		break;
	}

	switch (m_cellularReturnType)
	{
	case FastNoise::Distance2Edge:
		return sqrtf(distance2) - sqrtf(distance);
	case FastNoise::Distance2EdgeXValue:
		return (sqrtf(distance2) - sqrtf(distance)) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc)];

	case FastNoise::Distance2EdgeSq:
		return distance2 - distance;
	case FastNoise::Distance2EdgeSqXValue:
		return (distance2 - distance) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc, zc)];
	default:
		return 0.0f;
	}
}

float FastNoise::GetCellular(float x, float y)
{
	x *= m_frequency;
	y *= m_frequency;

	switch (m_cellularReturnType)
	{
	case Distance2Edge:
	case Distance2EdgeXValue:
	case Distance2EdgeSq:
	case Distance2EdgeSqXValue:
		return _Cellular2Edge(x, y);
	default:
		return _Cellular(x, y);
	}
}

float FastNoise::_Cellular(float x, float y)
{
	int xr = FastRound(x);
	int yr = FastRound(y);

	float distance = 999999.f;
	float newDistance;
	float vec[2];
	int lutPos;
	int xc, yc;

	switch (m_cellularDistanceFunction)
	{
	default:
	case FastNoise::Euclidean:
		for (int xi = xr - 1; xi <= xr + 1; xi++)
		{
			for (int yi = yr - 1; yi <= yr + 1; yi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi);

				vec[0] = xi - x + CELLULAR2D_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR2D_LUT[lutPos][1];

				newDistance = vec[0] * vec[0] + vec[1] * vec[1];

				if (newDistance < distance)
				{
					distance = newDistance;
					xc = xi;
					yc = yi;
				}
			}
		}
		break;
	case FastNoise::Manhattan:
		for (int xi = xr - 1; xi <= xr + 1; xi++)
		{
			for (int yi = yr - 1; yi <= yr + 1; yi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi);

				vec[0] = xi - x + CELLULAR2D_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR2D_LUT[lutPos][1];

				newDistance = (FastAbs(vec[0]) + FastAbs(vec[1]));

				if (newDistance < distance)
				{
					distance = newDistance;
					xc = xi;
					yc = yi;
				}
			}
		}
		break;
	case FastNoise::Natural:
		for (int xi = xr - 1; xi <= xr + 1; xi++)
		{
			for (int yi = yr - 1; yi <= yr + 1; yi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi);

				vec[0] = xi - x + CELLULAR2D_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR2D_LUT[lutPos][1];

				newDistance = (FastAbs(vec[0]) + FastAbs(vec[1])) * (vec[0] * vec[0] + vec[1] * vec[1]);

				if (newDistance < distance)
				{
					distance = newDistance;
					xc = xi;
					yc = yi;
				}
			}
		}
		break;
	}

	switch (m_cellularReturnType)
	{
	case FastNoise::CellValue:
		return VAL_LUT[CoordLUTIndex(m_seed, xc, yc)];

	case FastNoise::NoiseLookup:
		if (!m_cellularNoiseLookup)
			return 0;

		lutPos = CoordLUTIndex(m_seed, xc, yc);
		return m_cellularNoiseLookup->GetNoise(xc + CELLULAR2D_LUT[lutPos][0], yc + CELLULAR2D_LUT[lutPos][1]);

	case FastNoise::Distance2Center:
		return sqrtf(distance);
	case FastNoise::Distance2CenterXValue:
		return (1.0f - sqrtf(distance)) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc)];

	case FastNoise::Distance2CenterSq:
		return distance;
	case FastNoise::Distance2CenterSqXValue:
		return (1.0f - distance) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc)];
	default:
		return 0.0f;
	}
}

float FastNoise::_Cellular2Edge(float x, float y)
{
	int xr = FastRound(x);
	int yr = FastRound(y);

	float distance = 999999.f;
	float distance2 = 999999.f;
	float newDistance;
	float vec[2];
	int lutPos;
	int xc = 0, yc = 0;

	switch (m_cellularDistanceFunction)
	{
	default:
	case FastNoise::Euclidean:
		for (int xi = xr - 1; xi <= xr + 1; xi++)
		{
			for (int yi = yr - 1; yi <= yr + 1; yi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi);

				vec[0] = xi - x + CELLULAR2D_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR2D_LUT[lutPos][1];

				newDistance = vec[0] * vec[0] + vec[1] * vec[1];

				if (newDistance < distance)
				{
					distance2 = distance;

					distance = newDistance;
					xc = xi;
					yc = yi;
				}
				else if (newDistance < distance2)
				{
					distance2 = newDistance;
				}
			}
		}
		break;
	case FastNoise::Manhattan:
		for (int xi = xr - 1; xi <= xr + 1; xi++)
		{
			for (int yi = yr - 1; yi <= yr + 1; yi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi);

				vec[0] = xi - x + CELLULAR2D_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR2D_LUT[lutPos][1];

				newDistance = FastAbs(vec[0]) + FastAbs(vec[1]);

				if (newDistance < distance)
				{
					distance2 = distance;

					distance = newDistance;
					xc = xi;
					yc = yi;
				}
				else if (newDistance < distance2)
				{
					distance2 = newDistance;
				}
			}
		}
		break;
	case FastNoise::Natural:
		for (int xi = xr - 1; xi <= xr + 1; xi++)
		{
			for (int yi = yr - 1; yi <= yr + 1; yi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi);

				vec[0] = xi - x + CELLULAR2D_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR2D_LUT[lutPos][1];

				newDistance = (FastAbs(vec[0]) + FastAbs(vec[1])) * (vec[0] * vec[0] + vec[1] * vec[1]);

				if (newDistance < distance)
				{
					distance2 = distance;

					distance = newDistance;
					xc = xi;
					yc = yi;
				}
				else if (newDistance < distance2)
				{
					distance2 = newDistance;
				}
			}
		}
		break;
	}

	switch (m_cellularReturnType)
	{
	case FastNoise::Distance2Edge:
		return sqrtf(distance2) - sqrtf(distance);
	case FastNoise::Distance2EdgeXValue:
		return (sqrtf(distance2) - sqrtf(distance)) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc)];

	case FastNoise::Distance2EdgeSq:
		return distance2 - distance;
	case FastNoise::Distance2EdgeSqXValue:
		return (distance2 - distance) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc)];
	default:
		return 0.0f;
	}
}

float FastNoise::GetCellularHQ(float x, float y)
{
	x *= m_frequency;
	y *= m_frequency;

	switch (m_cellularReturnType)
	{
	case Distance2Edge:
	case Distance2EdgeXValue:
	case Distance2EdgeSq:
	case Distance2EdgeSqXValue:
		return _Cellular2EdgeHQ(x, y);
	default:
		return _CellularHQ(x, y);
	}
}

float FastNoise::_CellularHQ(float x, float y)
{
	int xr = FastRound(x);
	int yr = FastRound(y);

	float distance = 999999.f;
	float newDistance;
	float vec[2];
	int lutPos;
	int xc, yc;

	switch (m_cellularDistanceFunction)
	{
	default:
	case Euclidean:
		for (int xi = xr - 2; xi <= xr + 2; xi++)
		{
			for (int yi = yr - 2; yi <= yr + 2; yi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi);

				vec[0] = xi - x + CELLULAR2D_HQ_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR2D_HQ_LUT[lutPos][1];

				newDistance = vec[0] * vec[0] + vec[1] * vec[1];

				if (newDistance < distance)
				{
					distance = newDistance;
					xc = xi;
					yc = yi;
				}
			}
		}
		break;
	case Manhattan:
		for (int xi = xr - 2; xi <= xr + 2; xi++)
		{
			for (int yi = yr - 2; yi <= yr + 2; yi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi);

				vec[0] = xi - x + CELLULAR2D_HQ_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR2D_HQ_LUT[lutPos][1];

				newDistance = FastAbs(vec[0]) + FastAbs(vec[1]);

				if (newDistance < distance)
				{
					distance = newDistance;
					xc = xi;
					yc = yi;
				}
			}
		}
		break;
	case Natural:
		for (int xi = xr - 2; xi <= xr + 2; xi++)
		{
			for (int yi = yr - 2; yi <= yr + 2; yi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi);

				vec[0] = xi - x + CELLULAR2D_HQ_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR2D_HQ_LUT[lutPos][1];

				newDistance = (FastAbs(vec[0]) + FastAbs(vec[1])) * (vec[0] * vec[0] + vec[1] * vec[1]);

				if (newDistance < distance)
				{
					distance = newDistance;
					xc = xi;
					yc = yi;
				}
			}
		}
		break;
	}

	switch (m_cellularReturnType)
	{
	case FastNoise::CellValue:
		return VAL_LUT[CoordLUTIndex(m_seed, xc, yc)];

	case FastNoise::NoiseLookup:
		if (!m_cellularNoiseLookup)
			return 0;

		lutPos = CoordLUTIndex(m_seed, xc, yc);
		return m_cellularNoiseLookup->GetNoise(xc + CELLULAR2D_HQ_LUT[lutPos][0], yc + CELLULAR2D_HQ_LUT[lutPos][1]);

	case FastNoise::Distance2Center:
		return sqrtf(distance);
	case FastNoise::Distance2CenterXValue:
		return (1.0f - sqrtf(distance)) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc)];

	case FastNoise::Distance2CenterSq:
		return distance;
	case FastNoise::Distance2CenterSqXValue:
		return (1.0f - distance) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc)];
	default:
		return 0.0f;
	}
}

float FastNoise::_Cellular2EdgeHQ(float x, float y)
{
	int xr = FastRound(x);
	int yr = FastRound(y);

	float distance = 999999.f;
	float distance2 = 999999.f;
	float newDistance;
	float vec[2];
	int lutPos;
	int xc = 0, yc = 0;

	switch (m_cellularDistanceFunction)
	{
	default:
	case Euclidean:
		for (int xi = xr - 2; xi <= xr + 2; xi++)
		{
			for (int yi = yr - 2; yi <= yr + 2; yi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi);

				vec[0] = xi - x + CELLULAR2D_HQ_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR2D_HQ_LUT[lutPos][1];

				newDistance = vec[0] * vec[0] + vec[1] * vec[1];

				if (newDistance < distance)
				{
					distance2 = distance;

					distance = newDistance;
					xc = xi;
					yc = yi;
				}
				else if (newDistance < distance2)
				{
					distance2 = newDistance;
				}
			}
		}
		break;
	case Manhattan:
		for (int xi = xr - 2; xi <= xr + 2; xi++)
		{
			for (int yi = yr - 2; yi <= yr + 2; yi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi);

				vec[0] = xi - x + CELLULAR2D_HQ_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR2D_HQ_LUT[lutPos][1];

				newDistance = FastAbs(vec[0]) + FastAbs(vec[1]);

				if (newDistance < distance)
				{
					distance2 = distance;

					distance = newDistance;
					xc = xi;
					yc = yi;
				}
				else if (newDistance < distance2)
				{
					distance2 = newDistance;
				}
			}
		}
		break;
	case Natural:
		for (int xi = xr - 2; xi <= xr + 2; xi++)
		{
			for (int yi = yr - 2; yi <= yr + 2; yi++)
			{
				lutPos = CoordLUTIndex(m_seed, xi, yi);

				vec[0] = xi - x + CELLULAR2D_HQ_LUT[lutPos][0];
				vec[1] = yi - y + CELLULAR2D_HQ_LUT[lutPos][1];

				newDistance = (FastAbs(vec[0]) + FastAbs(vec[1])) * (vec[0] * vec[0] + vec[1] * vec[1]);

				if (newDistance < distance)
				{
					distance2 = distance;

					distance = newDistance;
					xc = xi;
					yc = yi;
				}
				else if (newDistance < distance2)
				{
					distance2 = newDistance;
				}
			}
		}
		break;
	}

	switch (m_cellularReturnType)
	{
	case FastNoise::Distance2Edge:
		return sqrtf(distance2) - sqrtf(distance);
	case FastNoise::Distance2EdgeXValue:
		return (sqrtf(distance2) - sqrtf(distance)) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc)];

	case FastNoise::Distance2EdgeSq:
		return distance2 - distance;
	case FastNoise::Distance2EdgeSqXValue:
		return (distance2 - distance) * VAL_LUT[CoordLUTIndex(m_seed, xc, yc)];
	default:
		return 0.0f;
	}
}

}